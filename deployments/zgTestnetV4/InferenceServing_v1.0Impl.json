{
  "address": "0xe6543f5C1d56da0a0E31f1DF651623994f6F3730",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "provider",
          "type": "address"
        }
      ],
      "name": "AccountExists",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "provider",
          "type": "address"
        }
      ],
      "name": "AccountNotExists",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "AdditionalInfoTooLong",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "reason",
          "type": "string"
        }
      ],
      "name": "InvalidTEESignature",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "provider",
          "type": "address"
        }
      ],
      "name": "ServiceNotExist",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "provider",
          "type": "address"
        }
      ],
      "name": "TooManyRefunds",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "provider",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newGeneration",
          "type": "uint256"
        }
      ],
      "name": "AllTokensRevoked",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "provider",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "pendingRefund",
          "type": "uint256"
        }
      ],
      "name": "BalanceUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address[]",
          "name": "users",
          "type": "address[]"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "balances",
          "type": "uint256[]"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "pendingRefunds",
          "type": "uint256[]"
        }
      ],
      "name": "BatchBalanceUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "provider",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "ProviderStakeReturned",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "provider",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "ProviderStaked",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "provider",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "teeSignerAddress",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "acknowledged",
          "type": "bool"
        }
      ],
      "name": "ProviderTEESignerAcknowledged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "provider",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "timestamp",
          "type": "uint256"
        }
      ],
      "name": "RefundRequested",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "service",
          "type": "address"
        }
      ],
      "name": "ServiceRemoved",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "service",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "serviceType",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "url",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "inputPrice",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "outputPrice",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "updatedAt",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "model",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "verifiability",
          "type": "string"
        }
      ],
      "name": "ServiceUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "enum SettlementStatus",
          "name": "status",
          "type": "uint8"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "unsettledAmount",
          "type": "uint256"
        }
      ],
      "name": "TEESettlementResult",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "provider",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "tokenId",
          "type": "uint8"
        }
      ],
      "name": "TokenRevoked",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "provider",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint8[]",
          "name": "tokenIds",
          "type": "uint8[]"
        }
      ],
      "name": "TokensRevoked",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "MAX_LOCKTIME",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MIN_LOCKTIME",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MIN_PROVIDER_STAKE",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "provider",
          "type": "address"
        }
      ],
      "name": "accountExists",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "provider",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "acknowledged",
          "type": "bool"
        }
      ],
      "name": "acknowledgeTEESigner",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "provider",
          "type": "address"
        }
      ],
      "name": "acknowledgeTEESignerByOwner",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "provider",
          "type": "address"
        },
        {
          "internalType": "string",
          "name": "additionalInfo",
          "type": "string"
        }
      ],
      "name": "addAccount",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "string",
              "name": "serviceType",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "url",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "model",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "verifiability",
              "type": "string"
            },
            {
              "internalType": "uint256",
              "name": "inputPrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "outputPrice",
              "type": "uint256"
            },
            {
              "internalType": "string",
              "name": "additionalInfo",
              "type": "string"
            },
            {
              "internalType": "address",
              "name": "teeSignerAddress",
              "type": "address"
            }
          ],
          "internalType": "struct ServiceParams",
          "name": "params",
          "type": "tuple"
        }
      ],
      "name": "addOrUpdateService",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "provider",
          "type": "address"
        }
      ],
      "name": "deleteAccount",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "provider",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "cancelRetrievingAmount",
          "type": "uint256"
        }
      ],
      "name": "depositFund",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "provider",
          "type": "address"
        }
      ],
      "name": "getAccount",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "user",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "provider",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "balance",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "pendingRefund",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "index",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "createdAt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "processed",
                  "type": "bool"
                }
              ],
              "internalType": "struct Refund[]",
              "name": "refunds",
              "type": "tuple[]"
            },
            {
              "internalType": "string",
              "name": "additionalInfo",
              "type": "string"
            },
            {
              "internalType": "bool",
              "name": "acknowledged",
              "type": "bool"
            },
            {
              "internalType": "uint256",
              "name": "validRefundsLength",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "generation",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "revokedBitmap",
              "type": "uint256"
            }
          ],
          "internalType": "struct Account",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "provider",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "offset",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "limit",
          "type": "uint256"
        }
      ],
      "name": "getAccountsByProvider",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "user",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "provider",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "balance",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "pendingRefund",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "index",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "createdAt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "processed",
                  "type": "bool"
                }
              ],
              "internalType": "struct Refund[]",
              "name": "refunds",
              "type": "tuple[]"
            },
            {
              "internalType": "string",
              "name": "additionalInfo",
              "type": "string"
            },
            {
              "internalType": "bool",
              "name": "acknowledged",
              "type": "bool"
            },
            {
              "internalType": "uint256",
              "name": "validRefundsLength",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "generation",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "revokedBitmap",
              "type": "uint256"
            }
          ],
          "internalType": "struct Account[]",
          "name": "accounts",
          "type": "tuple[]"
        },
        {
          "internalType": "uint256",
          "name": "total",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "offset",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "limit",
          "type": "uint256"
        }
      ],
      "name": "getAccountsByUser",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "user",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "provider",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "balance",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "pendingRefund",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "index",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "createdAt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "processed",
                  "type": "bool"
                }
              ],
              "internalType": "struct Refund[]",
              "name": "refunds",
              "type": "tuple[]"
            },
            {
              "internalType": "string",
              "name": "additionalInfo",
              "type": "string"
            },
            {
              "internalType": "bool",
              "name": "acknowledged",
              "type": "bool"
            },
            {
              "internalType": "uint256",
              "name": "validRefundsLength",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "generation",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "revokedBitmap",
              "type": "uint256"
            }
          ],
          "internalType": "struct Account[]",
          "name": "accounts",
          "type": "tuple[]"
        },
        {
          "internalType": "uint256",
          "name": "total",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "offset",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "limit",
          "type": "uint256"
        }
      ],
      "name": "getAllAccounts",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "user",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "provider",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "balance",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "pendingRefund",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "index",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "createdAt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "processed",
                  "type": "bool"
                }
              ],
              "internalType": "struct Refund[]",
              "name": "refunds",
              "type": "tuple[]"
            },
            {
              "internalType": "string",
              "name": "additionalInfo",
              "type": "string"
            },
            {
              "internalType": "bool",
              "name": "acknowledged",
              "type": "bool"
            },
            {
              "internalType": "uint256",
              "name": "validRefundsLength",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "generation",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "revokedBitmap",
              "type": "uint256"
            }
          ],
          "internalType": "struct Account[]",
          "name": "accounts",
          "type": "tuple[]"
        },
        {
          "internalType": "uint256",
          "name": "total",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "offset",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "limit",
          "type": "uint256"
        }
      ],
      "name": "getAllServices",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "provider",
              "type": "address"
            },
            {
              "internalType": "string",
              "name": "serviceType",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "url",
              "type": "string"
            },
            {
              "internalType": "uint256",
              "name": "inputPrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "outputPrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "updatedAt",
              "type": "uint256"
            },
            {
              "internalType": "string",
              "name": "model",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "verifiability",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "additionalInfo",
              "type": "string"
            },
            {
              "internalType": "address",
              "name": "teeSignerAddress",
              "type": "address"
            },
            {
              "internalType": "bool",
              "name": "teeSignerAcknowledged",
              "type": "bool"
            }
          ],
          "internalType": "struct Service[]",
          "name": "services",
          "type": "tuple[]"
        },
        {
          "internalType": "uint256",
          "name": "total",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "users",
          "type": "address[]"
        }
      ],
      "name": "getBatchAccountsByUsers",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "user",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "provider",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "balance",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "pendingRefund",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "index",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "createdAt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "processed",
                  "type": "bool"
                }
              ],
              "internalType": "struct Refund[]",
              "name": "refunds",
              "type": "tuple[]"
            },
            {
              "internalType": "string",
              "name": "additionalInfo",
              "type": "string"
            },
            {
              "internalType": "bool",
              "name": "acknowledged",
              "type": "bool"
            },
            {
              "internalType": "uint256",
              "name": "validRefundsLength",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "generation",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "revokedBitmap",
              "type": "uint256"
            }
          ],
          "internalType": "struct Account[]",
          "name": "accounts",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "provider",
          "type": "address"
        }
      ],
      "name": "getPendingRefund",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "provider",
          "type": "address"
        }
      ],
      "name": "getService",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "provider",
              "type": "address"
            },
            {
              "internalType": "string",
              "name": "serviceType",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "url",
              "type": "string"
            },
            {
              "internalType": "uint256",
              "name": "inputPrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "outputPrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "updatedAt",
              "type": "uint256"
            },
            {
              "internalType": "string",
              "name": "model",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "verifiability",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "additionalInfo",
              "type": "string"
            },
            {
              "internalType": "address",
              "name": "teeSignerAddress",
              "type": "address"
            },
            {
              "internalType": "bool",
              "name": "teeSignerAcknowledged",
              "type": "bool"
            }
          ],
          "internalType": "struct Service",
          "name": "service",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_locktime",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "_ledgerAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "initialized",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "provider",
          "type": "address"
        },
        {
          "internalType": "uint8",
          "name": "tokenId",
          "type": "uint8"
        }
      ],
      "name": "isTokenRevoked",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ledgerAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "lockTime",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "user",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "provider",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "totalFee",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "requestsHash",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct TEESettlementData[]",
          "name": "settlements",
          "type": "tuple[]"
        }
      ],
      "name": "previewSettlementResults",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "failedUsers",
          "type": "address[]"
        },
        {
          "internalType": "enum SettlementStatus[]",
          "name": "failureReasons",
          "type": "uint8[]"
        },
        {
          "internalType": "address[]",
          "name": "partialUsers",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "partialAmounts",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "provider",
          "type": "address"
        }
      ],
      "name": "processRefund",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "totalAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "balance",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "pendingRefund",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "removeService",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "provider",
          "type": "address"
        }
      ],
      "name": "requestRefundAll",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "provider",
          "type": "address"
        }
      ],
      "name": "revokeAllTokens",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "provider",
          "type": "address"
        }
      ],
      "name": "revokeTEESignerAcknowledgement",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "provider",
          "type": "address"
        },
        {
          "internalType": "uint8",
          "name": "tokenId",
          "type": "uint8"
        }
      ],
      "name": "revokeToken",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "provider",
          "type": "address"
        },
        {
          "internalType": "uint8[]",
          "name": "tokenIds",
          "type": "uint8[]"
        }
      ],
      "name": "revokeTokens",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "user",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "provider",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "totalFee",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "requestsHash",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct TEESettlementData[]",
          "name": "settlements",
          "type": "tuple[]"
        }
      ],
      "name": "settleFeesWithTEE",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "failedUsers",
          "type": "address[]"
        },
        {
          "internalType": "enum SettlementStatus[]",
          "name": "failureReasons",
          "type": "uint8[]"
        },
        {
          "internalType": "address[]",
          "name": "partialUsers",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "partialAmounts",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_locktime",
          "type": "uint256"
        }
      ],
      "name": "updateLockTime",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "transactionHash": "0x96c58307950626f92d4a93cd8175416bef60662be851c78c2321d1883cb9c11b",
  "receipt": {
    "to": null,
    "from": "0x6D233D2610c32f630ED53E8a7Cbf759568041f8f",
    "contractAddress": "0xe6543f5C1d56da0a0E31f1DF651623994f6F3730",
    "transactionIndex": 0,
    "gasUsed": "4183652",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000800000000000001000000000000000000000000040000000000000000000002000000000000000000000000000000000000000000000000001000000000000000000000000000000000000020000000000000000000800000000000000000000000000000000400000000000000000000000000000800000000001000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xa35fa745a965568f44ad958d61b0fd142c19f5c2017d7cfe348611d37d07028c",
    "transactionHash": "0x96c58307950626f92d4a93cd8175416bef60662be851c78c2321d1883cb9c11b",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 9420446,
        "transactionHash": "0x96c58307950626f92d4a93cd8175416bef60662be851c78c2321d1883cb9c11b",
        "address": "0xe6543f5C1d56da0a0E31f1DF651623994f6F3730",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000006d233d2610c32f630ed53e8a7cbf759568041f8f"
        ],
        "data": "0x",
        "logIndex": 0,
        "blockHash": "0xa35fa745a965568f44ad958d61b0fd142c19f5c2017d7cfe348611d37d07028c"
      }
    ],
    "blockNumber": 9420446,
    "cumulativeGasUsed": "4183652",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 6,
  "solcInputHash": "a79fc1d60dd8d5f2118e7558e9adae77",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"}],\"name\":\"AccountExists\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"}],\"name\":\"AccountNotExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AdditionalInfoTooLong\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"InvalidTEESignature\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"}],\"name\":\"ServiceNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"}],\"name\":\"TooManyRefunds\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newGeneration\",\"type\":\"uint256\"}],\"name\":\"AllTokensRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pendingRefund\",\"type\":\"uint256\"}],\"name\":\"BalanceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"pendingRefunds\",\"type\":\"uint256[]\"}],\"name\":\"BatchBalanceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ProviderStakeReturned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ProviderStaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"teeSignerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"acknowledged\",\"type\":\"bool\"}],\"name\":\"ProviderTEESignerAcknowledged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"RefundRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"}],\"name\":\"ServiceRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"serviceType\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"url\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inputPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outputPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"model\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"verifiability\",\"type\":\"string\"}],\"name\":\"ServiceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum SettlementStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unsettledAmount\",\"type\":\"uint256\"}],\"name\":\"TEESettlementResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"tokenId\",\"type\":\"uint8\"}],\"name\":\"TokenRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8[]\",\"name\":\"tokenIds\",\"type\":\"uint8[]\"}],\"name\":\"TokensRevoked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_LOCKTIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_LOCKTIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_PROVIDER_STAKE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"}],\"name\":\"accountExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"acknowledged\",\"type\":\"bool\"}],\"name\":\"acknowledgeTEESigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"}],\"name\":\"acknowledgeTEESignerByOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"additionalInfo\",\"type\":\"string\"}],\"name\":\"addAccount\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"serviceType\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"url\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"model\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"verifiability\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"inputPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputPrice\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"additionalInfo\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"teeSignerAddress\",\"type\":\"address\"}],\"internalType\":\"struct ServiceParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"addOrUpdateService\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"}],\"name\":\"deleteAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cancelRetrievingAmount\",\"type\":\"uint256\"}],\"name\":\"depositFund\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"}],\"name\":\"getAccount\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingRefund\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"processed\",\"type\":\"bool\"}],\"internalType\":\"struct Refund[]\",\"name\":\"refunds\",\"type\":\"tuple[]\"},{\"internalType\":\"string\",\"name\":\"additionalInfo\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"acknowledged\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"validRefundsLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"generation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"revokedBitmap\",\"type\":\"uint256\"}],\"internalType\":\"struct Account\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"getAccountsByProvider\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingRefund\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"processed\",\"type\":\"bool\"}],\"internalType\":\"struct Refund[]\",\"name\":\"refunds\",\"type\":\"tuple[]\"},{\"internalType\":\"string\",\"name\":\"additionalInfo\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"acknowledged\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"validRefundsLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"generation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"revokedBitmap\",\"type\":\"uint256\"}],\"internalType\":\"struct Account[]\",\"name\":\"accounts\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"getAccountsByUser\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingRefund\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"processed\",\"type\":\"bool\"}],\"internalType\":\"struct Refund[]\",\"name\":\"refunds\",\"type\":\"tuple[]\"},{\"internalType\":\"string\",\"name\":\"additionalInfo\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"acknowledged\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"validRefundsLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"generation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"revokedBitmap\",\"type\":\"uint256\"}],\"internalType\":\"struct Account[]\",\"name\":\"accounts\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"getAllAccounts\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingRefund\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"processed\",\"type\":\"bool\"}],\"internalType\":\"struct Refund[]\",\"name\":\"refunds\",\"type\":\"tuple[]\"},{\"internalType\":\"string\",\"name\":\"additionalInfo\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"acknowledged\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"validRefundsLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"generation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"revokedBitmap\",\"type\":\"uint256\"}],\"internalType\":\"struct Account[]\",\"name\":\"accounts\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"getAllServices\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"serviceType\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"url\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"inputPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"model\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"verifiability\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"additionalInfo\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"teeSignerAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"teeSignerAcknowledged\",\"type\":\"bool\"}],\"internalType\":\"struct Service[]\",\"name\":\"services\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"}],\"name\":\"getBatchAccountsByUsers\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingRefund\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"processed\",\"type\":\"bool\"}],\"internalType\":\"struct Refund[]\",\"name\":\"refunds\",\"type\":\"tuple[]\"},{\"internalType\":\"string\",\"name\":\"additionalInfo\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"acknowledged\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"validRefundsLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"generation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"revokedBitmap\",\"type\":\"uint256\"}],\"internalType\":\"struct Account[]\",\"name\":\"accounts\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"}],\"name\":\"getPendingRefund\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"}],\"name\":\"getService\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"serviceType\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"url\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"inputPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"model\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"verifiability\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"additionalInfo\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"teeSignerAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"teeSignerAcknowledged\",\"type\":\"bool\"}],\"internalType\":\"struct Service\",\"name\":\"service\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_locktime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_ledgerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tokenId\",\"type\":\"uint8\"}],\"name\":\"isTokenRevoked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ledgerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalFee\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"requestsHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct TEESettlementData[]\",\"name\":\"settlements\",\"type\":\"tuple[]\"}],\"name\":\"previewSettlementResults\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"failedUsers\",\"type\":\"address[]\"},{\"internalType\":\"enum SettlementStatus[]\",\"name\":\"failureReasons\",\"type\":\"uint8[]\"},{\"internalType\":\"address[]\",\"name\":\"partialUsers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"partialAmounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"}],\"name\":\"processRefund\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingRefund\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeService\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"}],\"name\":\"requestRefundAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"}],\"name\":\"revokeAllTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"}],\"name\":\"revokeTEESignerAcknowledgement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tokenId\",\"type\":\"uint8\"}],\"name\":\"revokeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"uint8[]\",\"name\":\"tokenIds\",\"type\":\"uint8[]\"}],\"name\":\"revokeTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalFee\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"requestsHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct TEESettlementData[]\",\"name\":\"settlements\",\"type\":\"tuple[]\"}],\"name\":\"settleFeesWithTEE\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"failedUsers\",\"type\":\"address[]\"},{\"internalType\":\"enum SettlementStatus[]\",\"name\":\"failureReasons\",\"type\":\"uint8[]\"},{\"internalType\":\"address[]\",\"name\":\"partialUsers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"partialAmounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_locktime\",\"type\":\"uint256\"}],\"name\":\"updateLockTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"supportsInterface(bytes4)\":{\"details\":\"See {IERC165-supportsInterface}.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/inference/InferenceServing.sol\":\"InferenceServing\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xa94b34880e3c1b0b931662cb1c09e5dfa6662f31cba80e07c5ee71cd135c9673\",\"license\":\"MIT\"},\"@openzeppelin/contracts/security/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0x190dd6f8d592b7e4e930feb7f4313aeb8e1c4ad3154c27ce1cf6a512fc30d8cc\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0xd10975de010d89fd1c78dc5e8a9a7e7f496198085c151648f20cba166b32582b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.2) (utils/introspection/ERC165Checker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Library used to query support of an interface declared via {IERC165}.\\n *\\n * Note that these functions return the actual result of the query: they do not\\n * `revert` if an interface is not supported. It is up to the caller to decide\\n * what to do in these cases.\\n */\\nlibrary ERC165Checker {\\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\\n\\n    /**\\n     * @dev Returns true if `account` supports the {IERC165} interface.\\n     */\\n    function supportsERC165(address account) internal view returns (bool) {\\n        // Any contract that implements ERC165 must explicitly indicate support of\\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\n        return\\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\\n            !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports the interface defined by\\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // query support of both ERC165 as per the spec and support of _interfaceId\\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns a boolean array where each value corresponds to the\\n     * interfaces passed in and whether they're supported or not. This allows\\n     * you to batch check interfaces for a contract where your expectation\\n     * is that some interfaces may not be supported.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\\n        internal\\n        view\\n        returns (bool[] memory)\\n    {\\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\\n\\n        // query support of ERC165 itself\\n        if (supportsERC165(account)) {\\n            // query support of each interface in interfaceIds\\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\\n            }\\n        }\\n\\n        return interfaceIdsSupported;\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports all the interfaces defined in\\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * Batch-querying can lead to gas savings by skipping repeated checks for\\n     * {IERC165} support.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\\n        // query support of ERC165 itself\\n        if (!supportsERC165(account)) {\\n            return false;\\n        }\\n\\n        // query support of each interface in interfaceIds\\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\\n                return false;\\n            }\\n        }\\n\\n        // all interfaces supported\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Query if a contract implements an interface, does not check ERC165 support\\n     * @param account The address of the contract to query for support of an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @return true if the contract at account indicates support of the interface with\\n     * identifier interfaceId, false otherwise\\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\\n     * the behavior of this method is undefined. This precondition can be checked\\n     * with {supportsERC165}.\\n     *\\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\\n     * should be exercised when using this function.\\n     *\\n     * Interface identification is specified in ERC-165.\\n     */\\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // prepare call\\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\\n\\n        // perform static call\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly {\\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\\n            returnSize := returndatasize()\\n            returnValue := mload(0x00)\\n        }\\n\\n        return success && returnSize >= 0x20 && returnValue > 0;\\n    }\\n}\\n\",\"keccak256\":\"0x6ac3ebc0fe0ac3a70a561aa19210b49af9aa530b89ebb1cdc8a5901aabf7212e\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa1e8e83cd0087785df04ac79fb395d9f3684caeaf973d9e2c71caef723a3a5d6\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableMap.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./EnumerableSet.sol\\\";\\n\\n/**\\n * @dev Library for managing an enumerable variant of Solidity's\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\n * type.\\n *\\n * Maps have the following properties:\\n *\\n * - Entries are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\\n *\\n *     // Declare a set state variable\\n *     EnumerableMap.UintToAddressMap private myMap;\\n * }\\n * ```\\n *\\n * The following map types are supported:\\n *\\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableMap.\\n * ====\\n */\\nlibrary EnumerableMap {\\n    using EnumerableSet for EnumerableSet.Bytes32Set;\\n\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Map type with\\n    // bytes32 keys and values.\\n    // The Map implementation uses private functions, and user-facing\\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\\n    // the underlying Map.\\n    // This means that we can only create new EnumerableMaps for types that fit\\n    // in bytes32.\\n\\n    struct Bytes32ToBytes32Map {\\n        // Storage of keys\\n        EnumerableSet.Bytes32Set _keys;\\n        mapping(bytes32 => bytes32) _values;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        Bytes32ToBytes32Map storage map,\\n        bytes32 key,\\n        bytes32 value\\n    ) internal returns (bool) {\\n        map._values[key] = value;\\n        return map._keys.add(key);\\n    }\\n\\n    /**\\n     * @dev Removes a key-value pair from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\\n        delete map._values[key];\\n        return map._keys.remove(key);\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\\n        return map._keys.contains(key);\\n    }\\n\\n    /**\\n     * @dev Returns the number of key-value pairs in the map. O(1).\\n     */\\n    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\\n        return map._keys.length();\\n    }\\n\\n    /**\\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of entries inside the\\n     * array, and it may change when more entries are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\\n        bytes32 key = map._keys.at(index);\\n        return (key, map._values[key]);\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\\n        bytes32 value = map._values[key];\\n        if (value == bytes32(0)) {\\n            return (contains(map, key), bytes32(0));\\n        } else {\\n            return (true, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\\n        bytes32 value = map._values[key];\\n        require(value != 0 || contains(map, key), \\\"EnumerableMap: nonexistent key\\\");\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        Bytes32ToBytes32Map storage map,\\n        bytes32 key,\\n        string memory errorMessage\\n    ) internal view returns (bytes32) {\\n        bytes32 value = map._values[key];\\n        require(value != 0 || contains(map, key), errorMessage);\\n        return value;\\n    }\\n\\n    // UintToUintMap\\n\\n    struct UintToUintMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        UintToUintMap storage map,\\n        uint256 key,\\n        uint256 value\\n    ) internal returns (bool) {\\n        return set(map._inner, bytes32(key), bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\\n        return remove(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\\n        return contains(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(UintToUintMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the set. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (uint256(key), uint256(value));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n        return (success, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(key)));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        UintToUintMap storage map,\\n        uint256 key,\\n        string memory errorMessage\\n    ) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(key), errorMessage));\\n    }\\n\\n    // UintToAddressMap\\n\\n    struct UintToAddressMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        UintToAddressMap storage map,\\n        uint256 key,\\n        address value\\n    ) internal returns (bool) {\\n        return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\n        return remove(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\n        return contains(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the set. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (uint256(key), address(uint160(uint256(value))));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n        return (success, address(uint160(uint256(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\n        return address(uint160(uint256(get(map._inner, bytes32(key)))));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        UintToAddressMap storage map,\\n        uint256 key,\\n        string memory errorMessage\\n    ) internal view returns (address) {\\n        return address(uint160(uint256(get(map._inner, bytes32(key), errorMessage))));\\n    }\\n\\n    // AddressToUintMap\\n\\n    struct AddressToUintMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        AddressToUintMap storage map,\\n        address key,\\n        uint256 value\\n    ) internal returns (bool) {\\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\\n        return remove(map._inner, bytes32(uint256(uint160(key))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\\n        return contains(map._inner, bytes32(uint256(uint160(key))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the set. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (address(uint160(uint256(key))), uint256(value));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\\n        return (success, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        AddressToUintMap storage map,\\n        address key,\\n        string memory errorMessage\\n    ) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(uint256(uint160(key))), errorMessage));\\n    }\\n\\n    // Bytes32ToUintMap\\n\\n    struct Bytes32ToUintMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        Bytes32ToUintMap storage map,\\n        bytes32 key,\\n        uint256 value\\n    ) internal returns (bool) {\\n        return set(map._inner, key, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\\n        return remove(map._inner, key);\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\\n        return contains(map._inner, key);\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the set. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (key, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\\n        (bool success, bytes32 value) = tryGet(map._inner, key);\\n        return (success, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\\n        return uint256(get(map._inner, key));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        Bytes32ToUintMap storage map,\\n        bytes32 key,\\n        string memory errorMessage\\n    ) internal view returns (uint256) {\\n        return uint256(get(map._inner, key, errorMessage));\\n    }\\n}\\n\",\"keccak256\":\"0x5094b17cb46143943f3206d0738b91a05a7005e979681af7210d534cd3e72f54\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\",\"keccak256\":\"0xc3ff3f5c4584e1d9a483ad7ced51ab64523201f4e3d3c65293e4ca8aeb77a961\",\"license\":\"MIT\"},\"contracts/inference/InferenceAccount.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\n\\nstruct Account {\\n    address user;\\n    address provider;\\n    uint nonce;\\n    uint balance;\\n    uint pendingRefund;\\n    Refund[] refunds;\\n    string additionalInfo;\\n    bool acknowledged; // Whether user has acknowledged this provider\\n    uint validRefundsLength; // Track the number of valid (non-dirty) refunds\\n    uint generation; // Token generation for batch revocation\\n    uint256 revokedBitmap; // Bitmap for precise token revocation (each bit represents a tokenId 0-255)\\n}\\n\\nstruct Refund {\\n    uint index;\\n    uint amount;\\n    uint createdAt;\\n    bool processed;\\n}\\n\\nlibrary AccountLibrary {\\n    using EnumerableSet for EnumerableSet.Bytes32Set;\\n\\n    // Constants for optimization\\n    uint constant MAX_REFUNDS_PER_ACCOUNT = 5;\\n    uint constant REFUND_CLEANUP_THRESHOLD = 3;\\n\\n    error AccountNotExists(address user, address provider);\\n    error AccountExists(address user, address provider);\\n    error InsufficientBalance(address user, address provider);\\n    error RefundInvalid(address user, address provider, uint index);\\n    error RefundProcessed(address user, address provider, uint index);\\n    error RefundLocked(address user, address provider, uint index);\\n    error TooManyRefunds(address user, address provider);\\n\\n    struct AccountMap {\\n        EnumerableSet.Bytes32Set _keys;\\n        mapping(bytes32 => Account) _values;\\n        mapping(address => EnumerableSet.Bytes32Set) _providerIndex;\\n        mapping(address => EnumerableSet.Bytes32Set) _userIndex;\\n    }\\n\\n    function getAccount(\\n        AccountMap storage map,\\n        address user,\\n        address provider\\n    ) internal view returns (Account storage) {\\n        return _get(map, user, provider);\\n    }\\n\\n    function getAllAccounts(\\n        AccountMap storage map,\\n        uint offset,\\n        uint limit\\n    ) internal view returns (Account[] memory accounts, uint total) {\\n        total = _length(map);\\n\\n        if (offset >= total) {\\n            return (new Account[](0), total);\\n        }\\n\\n        uint end = offset + limit;\\n        if (limit == 0 || end > total) {\\n            end = total;\\n        }\\n\\n        uint resultLength = end - offset;\\n        accounts = new Account[](resultLength);\\n\\n        for (uint i = 0; i < resultLength; i++) {\\n            accounts[i] = _at(map, offset + i);\\n        }\\n    }\\n\\n    function getAccountsByProvider(\\n        AccountMap storage map,\\n        address provider,\\n        uint offset,\\n        uint limit\\n    ) internal view returns (Account[] memory accounts, uint total) {\\n        EnumerableSet.Bytes32Set storage providerKeys = map._providerIndex[provider];\\n        total = providerKeys.length();\\n\\n        if (offset >= total) {\\n            return (new Account[](0), total);\\n        }\\n\\n        uint end = limit == 0 ? total : offset + limit;\\n        if (end > total) {\\n            end = total;\\n        }\\n\\n        uint resultLen = end - offset;\\n        accounts = new Account[](resultLen);\\n\\n        for (uint i = 0; i < resultLen; i++) {\\n            bytes32 key = providerKeys.at(offset + i);\\n            accounts[i] = map._values[key];\\n        }\\n\\n        return (accounts, total);\\n    }\\n\\n    function getAccountsByUser(\\n        AccountMap storage map,\\n        address user,\\n        uint offset,\\n        uint limit\\n    ) internal view returns (Account[] memory accounts, uint total) {\\n        EnumerableSet.Bytes32Set storage userKeys = map._userIndex[user];\\n        total = userKeys.length();\\n\\n        if (offset >= total) {\\n            return (new Account[](0), total);\\n        }\\n\\n        uint end = limit == 0 ? total : offset + limit;\\n        if (end > total) {\\n            end = total;\\n        }\\n\\n        uint resultLen = end - offset;\\n        accounts = new Account[](resultLen);\\n\\n        for (uint i = 0; i < resultLen; i++) {\\n            bytes32 key = userKeys.at(offset + i);\\n            accounts[i] = map._values[key];\\n        }\\n\\n        return (accounts, total);\\n    }\\n\\n    function getAccountCountByProvider(AccountMap storage map, address provider) internal view returns (uint) {\\n        return map._providerIndex[provider].length();\\n    }\\n\\n    function getAccountCountByUser(AccountMap storage map, address user) internal view returns (uint) {\\n        return map._userIndex[user].length();\\n    }\\n\\n    function getBatchAccountsByUsers(\\n        AccountMap storage map,\\n        address[] calldata users,\\n        address provider\\n    ) internal view returns (Account[] memory accounts) {\\n        require(users.length <= 500, \\\"Batch size too large (max 500)\\\");\\n        accounts = new Account[](users.length);\\n\\n        for (uint i = 0; i < users.length; i++) {\\n            bytes32 key = _key(users[i], provider);\\n            if (_contains(map, key)) {\\n                accounts[i] = map._values[key];\\n            }\\n        }\\n    }\\n\\n    function accountExists(AccountMap storage map, address user, address provider) internal view returns (bool) {\\n        return _contains(map, _key(user, provider));\\n    }\\n\\n    function getPendingRefund(AccountMap storage map, address user, address provider) internal view returns (uint) {\\n        Account storage account = _get(map, user, provider);\\n        return account.pendingRefund;\\n    }\\n\\n    function addAccount(\\n        AccountMap storage map,\\n        address user,\\n        address provider,\\n        uint amount,\\n        string memory additionalInfo\\n    ) internal returns (uint, uint) {\\n        bytes32 key = _key(user, provider);\\n        if (_contains(map, key)) {\\n            revert AccountExists(user, provider);\\n        }\\n\\n        _set(map, key, user, provider, amount, additionalInfo);\\n\\n        map._providerIndex[provider].add(key);\\n        map._userIndex[user].add(key);\\n\\n        return (amount, 0);\\n    }\\n\\n    function deleteAccount(AccountMap storage map, address user, address provider) internal {\\n        bytes32 key = _key(user, provider);\\n        if (!_contains(map, key)) {\\n            return;\\n        }\\n\\n        map._providerIndex[provider].remove(key);\\n        map._userIndex[user].remove(key);\\n        map._keys.remove(key);\\n        delete map._values[key];\\n    }\\n\\n    function acknowledgeTEESigner(\\n        AccountMap storage map,\\n        address user,\\n        address provider,\\n        bool acknowledged\\n    ) internal {\\n        Account storage account = _get(map, user, provider);\\n\\n        // Once acknowledged as true, can only be set back to false if balance is zero\\n        if (account.acknowledged && !acknowledged) {\\n            require(account.balance == 0, \\\"Cannot revoke acknowledgement with non-zero balance\\\");\\n        }\\n\\n        account.acknowledged = acknowledged;\\n    }\\n\\n    function revokeToken(\\n        AccountMap storage map,\\n        address user,\\n        address provider,\\n        uint8 tokenId\\n    ) internal {\\n        Account storage account = _get(map, user, provider);\\n        account.revokedBitmap |= (uint256(1) << tokenId);\\n    }\\n\\n    function revokeTokens(\\n        AccountMap storage map,\\n        address user,\\n        address provider,\\n        uint8[] calldata tokenIds\\n    ) internal {\\n        Account storage account = _get(map, user, provider);\\n        for (uint i = 0; i < tokenIds.length; i++) {\\n            account.revokedBitmap |= (uint256(1) << tokenIds[i]);\\n        }\\n    }\\n\\n    function revokeAllTokens(\\n        AccountMap storage map,\\n        address user,\\n        address provider\\n    ) internal returns (uint newGeneration) {\\n        Account storage account = _get(map, user, provider);\\n        account.generation++;\\n        account.revokedBitmap = 0; // Reset bitmap for new generation\\n        return account.generation;\\n    }\\n\\n    function isTokenRevoked(\\n        AccountMap storage map,\\n        address user,\\n        address provider,\\n        uint8 tokenId\\n    ) internal view returns (bool) {\\n        Account storage account = _get(map, user, provider);\\n        return (account.revokedBitmap & (uint256(1) << tokenId)) != 0;\\n    }\\n\\n    function depositFund(\\n        AccountMap storage map,\\n        address user,\\n        address provider,\\n        uint cancelRetrievingAmount,\\n        uint amount\\n    ) internal returns (uint, uint) {\\n        Account storage account = _get(map, user, provider);\\n\\n        if (cancelRetrievingAmount > 0 && account.refunds.length > 0) {\\n            uint remainingCancel = cancelRetrievingAmount;\\n            uint newPendingRefund = account.pendingRefund;\\n\\n            // Process refunds in-place to avoid memory allocation\\n            uint writeIndex = 0;\\n            for (uint i = 0; i < account.refunds.length; i++) {\\n                Refund storage refund = account.refunds[i];\\n\\n                if (refund.processed) {\\n                    continue;\\n                }\\n\\n                if (remainingCancel >= refund.amount) {\\n                    remainingCancel -= refund.amount;\\n                    newPendingRefund -= refund.amount;\\n                    refund.processed = true; // Mark as processed instead of removing\\n                } else if (remainingCancel > 0) {\\n                    refund.amount -= remainingCancel;\\n                    newPendingRefund -= remainingCancel;\\n                    remainingCancel = 0;\\n                }\\n\\n                // Keep unprocessed refunds\\n                if (!refund.processed && i != writeIndex) {\\n                    account.refunds[writeIndex] = refund;\\n                    account.refunds[writeIndex].index = writeIndex;\\n                    writeIndex++;\\n                } else if (!refund.processed) {\\n                    writeIndex++;\\n                }\\n            }\\n\\n            // Update validRefundsLength after cancelling refunds\\n            account.validRefundsLength = writeIndex;\\n\\n            // Cleanup if needed\\n            if (writeIndex < account.refunds.length) {\\n                _cleanupRefunds(account, writeIndex);\\n                account.validRefundsLength = account.refunds.length; // Update after cleanup\\n            }\\n\\n            account.pendingRefund = newPendingRefund;\\n        }\\n\\n        account.balance += amount;\\n        return (account.balance, account.pendingRefund);\\n    }\\n\\n    function requestRefund(\\n        AccountMap storage map,\\n        address user,\\n        address provider,\\n        uint amount\\n    ) internal returns (uint) {\\n        Account storage account = _get(map, user, provider);\\n        if ((account.balance - account.pendingRefund) < amount) {\\n            revert InsufficientBalance(user, provider);\\n        }\\n\\n        // Check refund limit using validRefundsLength\\n        if (account.validRefundsLength >= MAX_REFUNDS_PER_ACCOUNT) {\\n            revert TooManyRefunds(user, provider);\\n        }\\n\\n        uint newIndex;\\n        if (account.validRefundsLength < account.refunds.length) {\\n            // Reuse dirty position (saves ~15,000 gas)\\n            newIndex = account.validRefundsLength;\\n            account.refunds[newIndex] = Refund(newIndex, amount, block.timestamp, false);\\n        } else {\\n            // Need to push new position\\n            newIndex = account.refunds.length;\\n            account.refunds.push(Refund(newIndex, amount, block.timestamp, false));\\n        }\\n\\n        account.validRefundsLength++;\\n        account.pendingRefund += amount;\\n        return newIndex;\\n    }\\n\\n    function requestRefundAll(AccountMap storage map, address user, address provider) internal {\\n        Account storage account = _get(map, user, provider);\\n        uint amount = account.balance - account.pendingRefund;\\n        if (amount == 0) {\\n            return;\\n        }\\n\\n        // Check refund limit using validRefundsLength\\n        if (account.validRefundsLength >= MAX_REFUNDS_PER_ACCOUNT) {\\n            revert TooManyRefunds(user, provider);\\n        }\\n\\n        uint newIndex;\\n        if (account.validRefundsLength < account.refunds.length) {\\n            // Reuse dirty position (saves ~15,000 gas)\\n            newIndex = account.validRefundsLength;\\n            account.refunds[newIndex] = Refund(newIndex, amount, block.timestamp, false);\\n        } else {\\n            // Need to push new position\\n            newIndex = account.refunds.length;\\n            account.refunds.push(Refund(newIndex, amount, block.timestamp, false));\\n        }\\n\\n        account.validRefundsLength++;\\n        account.pendingRefund += amount;\\n    }\\n\\n    function processRefund(\\n        AccountMap storage map,\\n        address user,\\n        address provider,\\n        uint lockTime\\n    ) internal returns (uint totalAmount, uint balance, uint pendingRefund) {\\n        Account storage account = _get(map, user, provider);\\n\\n        if (account.refunds.length == 0) {\\n            return (0, account.balance, account.pendingRefund);\\n        }\\n\\n        totalAmount = 0;\\n        pendingRefund = 0;\\n        uint writeIndex = 0;\\n        uint currentTime = block.timestamp;\\n\\n        // Process refunds in-place\\n        for (uint i = 0; i < account.refunds.length; i++) {\\n            Refund storage refund = account.refunds[i];\\n\\n            if (refund.processed) {\\n                continue;\\n            }\\n\\n            if (currentTime >= refund.createdAt + lockTime) {\\n                totalAmount += refund.amount;\\n                refund.processed = true; // Mark as processed\\n            } else {\\n                pendingRefund += refund.amount;\\n                // Keep unprocessed refunds\\n                if (i != writeIndex) {\\n                    account.refunds[writeIndex] = refund;\\n                    account.refunds[writeIndex].index = writeIndex;\\n                }\\n                writeIndex++;\\n            }\\n        }\\n\\n        // Update valid refunds length\\n        account.validRefundsLength = writeIndex;\\n\\n        // Clean up or mark dirty data\\n        if (writeIndex < account.refunds.length) {\\n            uint dirtyCount = account.refunds.length - writeIndex;\\n\\n            if (dirtyCount >= REFUND_CLEANUP_THRESHOLD) {\\n                // Many dirty entries: physical cleanup is more efficient\\n                _cleanupRefunds(account, writeIndex);\\n                account.validRefundsLength = account.refunds.length; // Update after cleanup\\n            } else {\\n                // Few dirty entries: mark as processed to prevent duplicate processing\\n                for (uint i = writeIndex; i < account.refunds.length; i++) {\\n                    account.refunds[i].processed = true;\\n                }\\n            }\\n        }\\n\\n        account.balance -= totalAmount;\\n        account.pendingRefund = pendingRefund;\\n        balance = account.balance;\\n    }\\n\\n    function _cleanupRefunds(Account storage account, uint keepCount) private {\\n        // Resize array to remove processed refunds\\n        uint currentLength = account.refunds.length;\\n        for (uint i = currentLength; i > keepCount; i--) {\\n            account.refunds.pop();\\n        }\\n    }\\n\\n    function _at(AccountMap storage map, uint index) internal view returns (Account storage) {\\n        bytes32 key = map._keys.at(index);\\n        return map._values[key];\\n    }\\n\\n    function _contains(AccountMap storage map, bytes32 key) internal view returns (bool) {\\n        return map._keys.contains(key);\\n    }\\n\\n    function _length(AccountMap storage map) internal view returns (uint) {\\n        return map._keys.length();\\n    }\\n\\n    function _get(AccountMap storage map, address user, address provider) internal view returns (Account storage) {\\n        bytes32 key = _key(user, provider);\\n        if (!_contains(map, key)) {\\n            revert AccountNotExists(user, provider);\\n        }\\n        return map._values[key];\\n    }\\n\\n    function _set(\\n        AccountMap storage map,\\n        bytes32 key,\\n        address user,\\n        address provider,\\n        uint balance,\\n        string memory additionalInfo\\n    ) internal {\\n        Account storage account = map._values[key];\\n        account.balance = balance;\\n        account.user = user;\\n        account.provider = provider;\\n        account.additionalInfo = additionalInfo;\\n        account.validRefundsLength = 0; // Initialize validRefundsLength\\n        map._keys.add(key);\\n    }\\n\\n    function _key(address user, address provider) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(user, provider));\\n    }\\n}\\n\",\"keccak256\":\"0xfd90369399574d01b945cdc3b542e8489719353a3d753736fce31fb31940a345\",\"license\":\"Unlicense\"},\"contracts/inference/InferenceService.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\n\\nstruct ServiceParams {\\n    string serviceType;\\n    string url;\\n    string model;\\n    string verifiability;\\n    uint inputPrice;\\n    uint outputPrice;\\n    string additionalInfo;\\n    address teeSignerAddress;\\n}\\n\\nstruct Service {\\n    address provider;\\n    string serviceType;\\n    string url;\\n    uint inputPrice;\\n    uint outputPrice;\\n    uint updatedAt;\\n    string model;\\n    string verifiability;\\n    string additionalInfo;\\n    address teeSignerAddress;\\n    bool teeSignerAcknowledged;\\n}\\n\\nlibrary ServiceLibrary {\\n    using EnumerableSet for EnumerableSet.Bytes32Set;\\n\\n    uint constant MAX_ADDITIONAL_INFO_LENGTH = 4096; // 4KB limit for JSON configuration data\\n\\n    error ServiceNotExist(address provider);\\n    error AdditionalInfoTooLong();\\n\\n    struct ServiceMap {\\n        EnumerableSet.Bytes32Set _keys;\\n        mapping(bytes32 => Service) _values;\\n    }\\n\\n    function getService(ServiceMap storage map, address provider) internal view returns (Service storage) {\\n        return _get(map, provider);\\n    }\\n\\n    function getAllServices(\\n        ServiceMap storage map,\\n        uint offset,\\n        uint limit\\n    ) internal view returns (Service[] memory services, uint total) {\\n        total = _length(map);\\n\\n        if (offset >= total) {\\n            return (new Service[](0), total);\\n        }\\n\\n        uint end = offset + limit;\\n        if (limit == 0 || end > total) {\\n            end = total;\\n        }\\n\\n        uint resultLength = end - offset;\\n        services = new Service[](resultLength);\\n\\n        for (uint i = 0; i < resultLength; i++) {\\n            services[i] = _at(map, offset + i);\\n        }\\n    }\\n\\n    function addOrUpdateService(ServiceMap storage map, address provider, ServiceParams calldata params) internal {\\n        if (bytes(params.additionalInfo).length > MAX_ADDITIONAL_INFO_LENGTH) {\\n            revert AdditionalInfoTooLong();\\n        }\\n        bytes32 key = _key(provider);\\n        if (!_contains(map, key)) {\\n            _set(\\n                map,\\n                key,\\n                Service(\\n                    provider,\\n                    params.serviceType,\\n                    params.url,\\n                    params.inputPrice,\\n                    params.outputPrice,\\n                    block.timestamp,\\n                    params.model,\\n                    params.verifiability,\\n                    params.additionalInfo,\\n                    params.teeSignerAddress,\\n                    false  // teeSignerAcknowledged - default to false, needs owner acknowledgement\\n                )\\n            );\\n            return;\\n        }\\n        Service storage value = _get(map, provider);\\n        \\n        // Check if critical fields are being changed (fields that require re-acknowledgement)\\n        bool criticalFieldsChanged = (\\n            keccak256(bytes(value.serviceType)) != keccak256(bytes(params.serviceType)) ||\\n            keccak256(bytes(value.model)) != keccak256(bytes(params.model)) ||\\n            keccak256(bytes(value.verifiability)) != keccak256(bytes(params.verifiability)) ||\\n            value.teeSignerAddress != params.teeSignerAddress ||\\n            keccak256(bytes(value.additionalInfo)) != keccak256(bytes(params.additionalInfo))\\n        );\\n        \\n        // Update all fields\\n        value.serviceType = params.serviceType;\\n        value.inputPrice = params.inputPrice;\\n        value.outputPrice = params.outputPrice;\\n        value.url = params.url;\\n        value.updatedAt = block.timestamp;\\n        value.model = params.model;\\n        value.verifiability = params.verifiability;\\n        value.additionalInfo = params.additionalInfo;\\n        value.teeSignerAddress = params.teeSignerAddress;\\n        \\n        // Reset acknowledgement if critical fields changed\\n        // Only price and URL changes don't require re-acknowledgement\\n        if (criticalFieldsChanged) {\\n            value.teeSignerAcknowledged = false;\\n        }\\n    }\\n\\n    function removeService(ServiceMap storage map, address provider) internal {\\n        bytes32 key = _key(provider);\\n        if (!_contains(map, key)) {\\n            revert ServiceNotExist(provider);\\n        }\\n        _remove(map, key);\\n    }\\n\\n    function acknowledgeTEESigner(ServiceMap storage map, address provider) internal {\\n        Service storage service = _get(map, provider);\\n        service.teeSignerAcknowledged = true;\\n    }\\n\\n    function revokeTEESignerAcknowledgement(ServiceMap storage map, address provider) internal {\\n        Service storage service = _get(map, provider);\\n        service.teeSignerAcknowledged = false;\\n    }\\n\\n    function _at(ServiceMap storage map, uint index) internal view returns (Service storage) {\\n        bytes32 key = map._keys.at(index);\\n        return map._values[key];\\n    }\\n\\n    function _set(ServiceMap storage map, bytes32 key, Service memory value) internal returns (bool) {\\n        map._values[key] = value;\\n        return map._keys.add(key);\\n    }\\n\\n    function _get(ServiceMap storage map, address provider) internal view returns (Service storage) {\\n        bytes32 key = _key(provider);\\n        Service storage value = map._values[key];\\n        if (!_contains(map, key)) {\\n            revert ServiceNotExist(provider);\\n        }\\n        return value;\\n    }\\n\\n    function _remove(ServiceMap storage map, bytes32 key) internal returns (bool) {\\n        delete map._values[key];\\n        return map._keys.remove(key);\\n    }\\n\\n    function _contains(ServiceMap storage map, bytes32 key) internal view returns (bool) {\\n        return map._keys.contains(key);\\n    }\\n\\n    function _length(ServiceMap storage map) internal view returns (uint) {\\n        return map._keys.length();\\n    }\\n\\n    function _key(address provider) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(provider));\\n    }\\n}\\n\",\"keccak256\":\"0x6b58c83db024bb7204b8f8e5e74fe1d4fb3f0c150ca9906a07d051a3b4d602da\",\"license\":\"Unlicense\"},\"contracts/inference/InferenceServing.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"../utils/Initializable.sol\\\";\\nimport \\\"./InferenceAccount.sol\\\";\\nimport \\\"./InferenceService.sol\\\";\\nimport \\\"../ledger/LedgerManager.sol\\\";\\n\\nstruct TEESettlementData {\\n    address user;\\n    address provider;\\n    uint totalFee;\\n    bytes32 requestsHash;\\n    uint nonce;\\n    bytes signature;\\n}\\n\\nenum SettlementStatus {\\n    SUCCESS,              // 0: Full settlement success\\n    PARTIAL,              // 1: Partial settlement (insufficient balance)\\n    PROVIDER_MISMATCH,    // 2: Provider mismatch\\n    NO_TEE_SIGNER,        // 3: TEE signer not acknowledged\\n    INVALID_NONCE,        // 4: Invalid or duplicate nonce\\n    INVALID_SIGNATURE     // 5: Signature verification failed\\n}\\n\\ncontract InferenceServing is Ownable, Initializable, ReentrancyGuard, IServing, ERC165 {\\n    using AccountLibrary for AccountLibrary.AccountMap;\\n    using ServiceLibrary for ServiceLibrary.ServiceMap;\\n\\n    // @custom:storage-location erc7201:0g.serving.inference.v1.0\\n    struct InferenceServingStorage {\\n        uint lockTime;\\n        address ledgerAddress;\\n        ILedger ledger;\\n        AccountLibrary.AccountMap accountMap;\\n        ServiceLibrary.ServiceMap serviceMap;\\n        mapping(address => uint) providerStake; // Service provider stake amounts\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"0g.serving.inference.v1.0\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant INFERENCE_SERVING_STORAGE_LOCATION = 0xdfd123095cdedb1cecbc229b30f7cf8745fb3d3951645ac4a8fa4c0895f89500;\\n    \\n    // Enforce sane lockTime to avoid instant bypass (0) or excessive freeze (> 7 days)\\n    uint public constant MIN_LOCKTIME = 1 hours;\\n    uint public constant MAX_LOCKTIME = 7 days;\\n\\n    // Service provider stake requirement\\n    uint public constant MIN_PROVIDER_STAKE = 100 ether; // 100 0G minimum stake\\n\\n    function _getInferenceServingStorage() private pure returns (InferenceServingStorage storage $) {\\n        assembly {\\n            $.slot := INFERENCE_SERVING_STORAGE_LOCATION\\n        }\\n    }\\n\\n    // Public getters for compatibility\\n    function lockTime() public view returns (uint) {\\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\\n        return $.lockTime;\\n    }\\n\\n    function ledgerAddress() public view returns (address) {\\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\\n        return $.ledgerAddress;\\n    }\\n\\n    event BalanceUpdated(address indexed user, address indexed provider, uint amount, uint pendingRefund);\\n    event RefundRequested(address indexed user, address indexed provider, uint indexed index, uint timestamp);\\n    event ServiceUpdated(\\n        address indexed service,\\n        string serviceType,\\n        string url,\\n        uint inputPrice,\\n        uint outputPrice,\\n        uint updatedAt,\\n        string model,\\n        string verifiability\\n    );\\n    event ServiceRemoved(address indexed service);\\n    event TEESettlementResult(address indexed user, SettlementStatus status, uint256 unsettledAmount);\\n    event BatchBalanceUpdated(address[] users, uint256[] balances, uint256[] pendingRefunds);\\n    event ProviderTEESignerAcknowledged(address indexed provider, address indexed teeSignerAddress, bool acknowledged);\\n    event ProviderStaked(address indexed provider, uint amount);\\n    event ProviderStakeReturned(address indexed provider, uint amount);\\n    // Session token revocation events\\n    event TokenRevoked(address indexed user, address indexed provider, uint8 tokenId);\\n    event TokensRevoked(address indexed user, address indexed provider, uint8[] tokenIds);\\n    event AllTokensRevoked(address indexed user, address indexed provider, uint newGeneration);\\n    error InvalidTEESignature(string reason);\\n\\n    function initialize(uint _locktime, address _ledgerAddress, address owner) public onlyInitializeOnce {\\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\\n        _transferOwnership(owner);\\n        require(\\n            _locktime >= MIN_LOCKTIME && _locktime <= MAX_LOCKTIME,\\n            \\\"lockTime out of range\\\"\\n        );\\n        $.lockTime = _locktime;\\n        $.ledgerAddress = _ledgerAddress;\\n        $.ledger = ILedger(_ledgerAddress);\\n    }\\n\\n    modifier onlyLedger() {\\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\\n        require(msg.sender == $.ledgerAddress, \\\"Caller is not the ledger contract\\\");\\n        _;\\n    }\\n\\n    function updateLockTime(uint _locktime) public onlyOwner {\\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\\n        require(\\n            _locktime >= MIN_LOCKTIME && _locktime <= MAX_LOCKTIME,\\n            \\\"lockTime out of range\\\"\\n        );\\n        $.lockTime = _locktime;\\n    }\\n\\n    function getAccount(address user, address provider) public view returns (Account memory) {\\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\\n        return $.accountMap.getAccount(user, provider);\\n    }\\n\\n    function getAllAccounts(uint offset, uint limit) public view returns (Account[] memory accounts, uint total) {\\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\\n        require(limit == 0 || limit <= 50, \\\"Limit too large\\\");\\n        return $.accountMap.getAllAccounts(offset, (limit == 0 ? 50 : limit));\\n    }\\n\\n    function getAccountsByProvider(\\n        address provider,\\n        uint offset,\\n        uint limit\\n    ) public view returns (Account[] memory accounts, uint total) {\\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\\n        require(limit == 0 || limit <= 50, \\\"Limit too large\\\");\\n        return $.accountMap.getAccountsByProvider(provider, offset, (limit == 0 ? 50 : limit));\\n    }\\n\\n    function getAccountsByUser(\\n        address user,\\n        uint offset,\\n        uint limit\\n    ) public view returns (Account[] memory accounts, uint total) {\\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\\n        require(limit == 0 || limit <= 50, \\\"Limit too large\\\");\\n        return $.accountMap.getAccountsByUser(user, offset, (limit == 0 ? 50 : limit));\\n    }\\n\\n    function getBatchAccountsByUsers(address[] calldata users) external view returns (Account[] memory accounts) {\\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\\n        return $.accountMap.getBatchAccountsByUsers(users, msg.sender);\\n    }\\n\\n    function acknowledgeTEESignerByOwner(address provider) external onlyOwner {\\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\\n        Service storage service = $.serviceMap.getService(provider);\\n        $.serviceMap.acknowledgeTEESigner(provider);\\n        emit ProviderTEESignerAcknowledged(provider, service.teeSignerAddress, true);\\n    }\\n\\n    function acknowledgeTEESigner(address provider, bool acknowledged) external {\\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\\n        $.accountMap.acknowledgeTEESigner(msg.sender, provider, acknowledged);\\n    }\\n\\n\\n    function revokeTEESignerAcknowledgement(address provider) external onlyOwner {\\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\\n        Service storage service = $.serviceMap.getService(provider);\\n        $.serviceMap.revokeTEESignerAcknowledgement(provider);\\n        emit ProviderTEESignerAcknowledged(provider, service.teeSignerAddress, false);\\n    }\\n\\n    function revokeToken(address provider, uint8 tokenId) external {\\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\\n        $.accountMap.revokeToken(msg.sender, provider, tokenId);\\n        emit TokenRevoked(msg.sender, provider, tokenId);\\n    }\\n\\n    function revokeTokens(address provider, uint8[] calldata tokenIds) external {\\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\\n        $.accountMap.revokeTokens(msg.sender, provider, tokenIds);\\n        emit TokensRevoked(msg.sender, provider, tokenIds);\\n    }\\n\\n    function revokeAllTokens(address provider) external {\\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\\n        uint newGeneration = $.accountMap.revokeAllTokens(msg.sender, provider);\\n        emit AllTokensRevoked(msg.sender, provider, newGeneration);\\n    }\\n\\n    function isTokenRevoked(address user, address provider, uint8 tokenId) external view returns (bool) {\\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\\n        return $.accountMap.isTokenRevoked(user, provider, tokenId);\\n    }\\n\\n\\n    function accountExists(address user, address provider) public view returns (bool) {\\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\\n        return $.accountMap.accountExists(user, provider);\\n    }\\n\\n    function getPendingRefund(address user, address provider) public view returns (uint) {\\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\\n        return $.accountMap.getPendingRefund(user, provider);\\n    }\\n\\n    function addAccount(\\n        address user,\\n        address provider,\\n        string memory additionalInfo\\n    ) external payable onlyLedger {\\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\\n        (uint balance, uint pendingRefund) = $.accountMap.addAccount(user, provider, msg.value, additionalInfo);\\n\\n        // Auto-acknowledge TEE signer when user transfers funds to provider\\n        $.accountMap.acknowledgeTEESigner(user, provider, true);\\n\\n        emit BalanceUpdated(user, provider, balance, pendingRefund);\\n    }\\n\\n    function deleteAccount(address user, address provider) external onlyLedger {\\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\\n        $.accountMap.deleteAccount(user, provider);\\n    }\\n\\n    function depositFund(address user, address provider, uint cancelRetrievingAmount) external payable onlyLedger {\\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\\n        (uint balance, uint pendingRefund) = $.accountMap.depositFund(user, provider, cancelRetrievingAmount, msg.value);\\n\\n        // Auto-acknowledge TEE signer when user deposits funds to provider (if not already acknowledged)\\n        Account storage account = $.accountMap.getAccount(user, provider);\\n        if (!account.acknowledged) {\\n            $.accountMap.acknowledgeTEESigner(user, provider, true);\\n        }\\n\\n        emit BalanceUpdated(user, provider, balance, pendingRefund);\\n    }\\n\\n    function requestRefundAll(address user, address provider) external onlyLedger {\\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\\n        $.accountMap.requestRefundAll(user, provider);\\n        Account memory account = $.accountMap.getAccount(user, provider);\\n        if (account.refunds.length > 0) {\\n            emit RefundRequested(user, provider, account.refunds.length - 1, block.timestamp);\\n        }\\n    }\\n\\n    function processRefund(\\n        address user,\\n        address provider\\n    ) external onlyLedger returns (uint totalAmount, uint balance, uint pendingRefund) {\\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\\n        (totalAmount, balance, pendingRefund) = $.accountMap.processRefund(user, provider, $.lockTime);\\n\\n        if (totalAmount > 0) {\\n            (bool success, ) = payable(msg.sender).call{value: totalAmount}(\\\"\\\");\\n            require(success, \\\"transfer to ledger failed\\\");\\n            emit BalanceUpdated(user, provider, balance, pendingRefund);\\n        }\\n    }\\n\\n    function getService(address provider) public view returns (Service memory service) {\\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\\n        service = $.serviceMap.getService(provider);\\n    }\\n\\n    function getAllServices(uint offset, uint limit) public view returns (Service[] memory services, uint total) {\\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\\n        require(limit == 0 || limit <= 50, \\\"Limit too large\\\");\\n        return $.serviceMap.getAllServices(offset, (limit == 0 ? 50 : limit));\\n    }\\n\\n    function addOrUpdateService(ServiceParams calldata params) external payable {\\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\\n        if ($.providerStake[msg.sender] > 0) {\\n            // Updating existing service: cannot add more stake\\n            require(msg.value == 0, \\\"Cannot add more stake when updating service\\\");\\n        } else {\\n            // First time registration: require stake\\n            require(msg.value >= MIN_PROVIDER_STAKE, \\\"Minimum stake of 100 0G required\\\");\\n            $.providerStake[msg.sender] = msg.value;\\n\\n            emit ProviderStaked(msg.sender, msg.value);\\n        }\\n\\n        $.serviceMap.addOrUpdateService(msg.sender, params);\\n        emit ServiceUpdated(\\n            msg.sender,\\n            params.serviceType,\\n            params.url,\\n            params.inputPrice,\\n            params.outputPrice,\\n            block.timestamp,\\n            params.model,\\n            params.verifiability\\n        );\\n    }\\n\\n    function removeService() external nonReentrant {\\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\\n        $.serviceMap.removeService(msg.sender);\\n\\n        // Return stake if any\\n        uint stake = $.providerStake[msg.sender];\\n        if (stake > 0) {\\n            $.providerStake[msg.sender] = 0;\\n\\n            (bool success, ) = payable(msg.sender).call{value: stake}(\\\"\\\");\\n            require(success, \\\"Stake return failed\\\");\\n\\n            emit ProviderStakeReturned(msg.sender, stake);\\n        }\\n\\n        emit ServiceRemoved(msg.sender);\\n    }\\n\\n    function _settleFees(Account storage account, uint amount) private {\\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\\n        if (amount > (account.balance - account.pendingRefund)) {\\n            uint remainingFee = amount - (account.balance - account.pendingRefund);\\n            account.pendingRefund -= remainingFee;\\n            for (int i = int(account.refunds.length - 1); i >= 0; i--) {\\n                Refund storage refund = account.refunds[uint(i)];\\n                if (refund.processed) {\\n                    continue;\\n                }\\n\\n                if (refund.amount <= remainingFee) {\\n                    remainingFee -= refund.amount;\\n                    refund.amount = 0;           // Clear consumed amount\\n                    refund.processed = true;     // Mark as processed to prevent double-counting\\n                } else {\\n                    refund.amount -= remainingFee;\\n                    remainingFee = 0;\\n                }\\n\\n                if (remainingFee == 0) {\\n                    break;\\n                }\\n            }\\n        }\\n        account.balance -= amount;\\n        $.ledger.spendFund(account.user, amount);\\n        emit BalanceUpdated(account.user, msg.sender, account.balance, account.pendingRefund);\\n    }\\n\\n    // Static view function for previewing settlement results without state changes\\n    function previewSettlementResults(\\n        TEESettlementData[] calldata settlements\\n    ) external view returns (\\n        address[] memory failedUsers,\\n        SettlementStatus[] memory failureReasons,\\n        address[] memory partialUsers, \\n        uint256[] memory partialAmounts\\n    ) {\\n        require(settlements.length > 0, \\\"No settlements provided\\\");\\n\\n        failedUsers = new address[](settlements.length);\\n        failureReasons = new SettlementStatus[](settlements.length);\\n        partialUsers = new address[](settlements.length);\\n        partialAmounts = new uint256[](settlements.length);\\n        \\n        uint failedCount = 0;\\n        uint partialCount = 0;\\n\\n        for (uint i = 0; i < settlements.length; i++) {\\n            TEESettlementData calldata settlement = settlements[i];\\n            \\n            if (settlement.provider != msg.sender) {\\n                _recordFailure(failedUsers, failureReasons, failedCount++, settlement.user, SettlementStatus.PROVIDER_MISMATCH);\\n                continue;\\n            }\\n            \\n            (SettlementStatus status, uint256 unsettledAmount) = _previewTEESettlement(settlement);\\n            \\n            if (status == SettlementStatus.SUCCESS) {\\n                continue;\\n            }\\n            \\n            if (status == SettlementStatus.PARTIAL) {\\n                _recordPartial(partialUsers, partialAmounts, partialCount++, settlement.user, unsettledAmount);\\n                continue;\\n            }\\n            _recordFailure(failedUsers, failureReasons, failedCount++, settlement.user, status);\\n        }\\n\\n        assembly {\\n            mstore(failedUsers, failedCount)\\n            mstore(failureReasons, failedCount)\\n            mstore(partialUsers, partialCount)\\n            mstore(partialAmounts, partialCount)\\n        }\\n    }\\n\\n    function settleFeesWithTEE(\\n        TEESettlementData[] calldata settlements\\n    ) external returns (\\n        address[] memory failedUsers,\\n        SettlementStatus[] memory failureReasons,\\n        address[] memory partialUsers, \\n        uint256[] memory partialAmounts\\n    ) {\\n        require(settlements.length > 0, \\\"No settlements provided\\\");\\n        require(settlements.length <= 50, \\\"Too many settlements in batch\\\");\\n\\n        failedUsers = new address[](settlements.length);\\n        failureReasons = new SettlementStatus[](settlements.length);\\n        partialUsers = new address[](settlements.length);\\n        partialAmounts = new uint256[](settlements.length);\\n        \\n        uint failedCount = 0;\\n        uint partialCount = 0;\\n        uint256 totalTransferAmount = 0;\\n\\n        for (uint i = 0; i < settlements.length; i++) {\\n            TEESettlementData calldata settlement = settlements[i];\\n            \\n            if (settlement.provider != msg.sender) {\\n                _recordFailure(failedUsers, failureReasons, failedCount++, settlement.user, SettlementStatus.PROVIDER_MISMATCH);\\n                emit TEESettlementResult(settlement.user, SettlementStatus.PROVIDER_MISMATCH, settlement.totalFee);\\n                continue;\\n            }\\n            \\n            (SettlementStatus status, uint256 unsettledAmount, uint256 settledAmount) = _processTEESettlement(settlement);\\n            totalTransferAmount += settledAmount;\\n            emit TEESettlementResult(settlement.user, status, unsettledAmount);\\n            \\n            if (status == SettlementStatus.SUCCESS) {\\n                continue;\\n            }\\n            \\n            if (status == SettlementStatus.PARTIAL) {\\n                _recordPartial(partialUsers, partialAmounts, partialCount++, settlement.user, unsettledAmount);\\n                continue;\\n            }\\n            _recordFailure(failedUsers, failureReasons, failedCount++, settlement.user, status);\\n        }\\n\\n        assembly {\\n            mstore(failedUsers, failedCount)\\n            mstore(failureReasons, failedCount)\\n            mstore(partialUsers, partialCount)\\n            mstore(partialAmounts, partialCount)\\n        }\\n\\n        // Batch transfer all settled amounts at once\\n        if (totalTransferAmount > 0) {\\n            payable(msg.sender).transfer(totalTransferAmount);\\n        }\\n    }\\n\\n    // View function to preview settlement without state changes\\n    function _previewTEESettlement(TEESettlementData calldata settlement) private view returns (SettlementStatus status, uint256 unsettledAmount) {\\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\\n        Account storage account = $.accountMap.getAccount(settlement.user, msg.sender);\\n\\n        // Validate TEE signer acknowledgement - both user and service must be acknowledged, and service must have valid TEE signer address\\n        Service storage service = $.serviceMap.getService(msg.sender);\\n        if (!account.acknowledged || !service.teeSignerAcknowledged || service.teeSignerAddress == address(0)) {\\n            return (SettlementStatus.NO_TEE_SIGNER, settlement.totalFee);\\n        }\\n\\n        // Validate nonce (check if nonce would be valid)\\n        if (account.nonce >= settlement.nonce) {\\n            return (SettlementStatus.INVALID_NONCE, settlement.totalFee);\\n        }\\n\\n        // Validate signature using service TEE signer address\\n        if (!_verifySignature(settlement, service.teeSignerAddress)) {\\n            return (SettlementStatus.INVALID_SIGNATURE, settlement.totalFee);\\n        }\\n\\n        // Calculate settlement amounts (without modifying state)\\n        uint256 balance = account.balance;\\n        uint256 unsettled = settlement.totalFee > balance ? settlement.totalFee - balance : 0;\\n        \\n        // Return appropriate status\\n        if (unsettled > 0) {\\n            return (SettlementStatus.PARTIAL, unsettled);\\n        } else {\\n            return (SettlementStatus.SUCCESS, 0);\\n        }\\n    }\\n\\n    function _processTEESettlement(TEESettlementData calldata settlement) private returns (SettlementStatus status, uint256 unsettledAmount, uint256 settledAmount) {\\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\\n        Account storage account = $.accountMap.getAccount(settlement.user, msg.sender);\\n\\n        // Validate TEE signer acknowledgement - both user and service must be acknowledged, and service must have valid TEE signer address\\n        Service storage service = $.serviceMap.getService(msg.sender);\\n        if (!account.acknowledged || !service.teeSignerAcknowledged || service.teeSignerAddress == address(0)) {\\n            return (SettlementStatus.NO_TEE_SIGNER, settlement.totalFee, 0);\\n        }\\n\\n        // Validate nonce\\n        if (account.nonce >= settlement.nonce) {\\n            return (SettlementStatus.INVALID_NONCE, settlement.totalFee, 0);\\n        }\\n\\n        // Validate signature using service TEE signer address\\n        if (!_verifySignature(settlement, service.teeSignerAddress)) {\\n            return (SettlementStatus.INVALID_SIGNATURE, settlement.totalFee, 0);\\n        }\\n\\n        // All validations passed, update nonce\\n        account.nonce = settlement.nonce;\\n\\n        // Calculate settlement amounts\\n        uint256 balance = account.balance;\\n        uint256 toSettle = settlement.totalFee > balance ? balance : settlement.totalFee;\\n        uint256 unsettled = settlement.totalFee > balance ? settlement.totalFee - balance : 0;\\n        \\n        // Settle what we can\\n        if (toSettle > 0) {\\n            _settleFees(account, toSettle);\\n        }\\n\\n        // Return appropriate status\\n        if (unsettled > 0) {\\n            return (SettlementStatus.PARTIAL, unsettled, toSettle);\\n        } else {\\n            return (SettlementStatus.SUCCESS, 0, toSettle);\\n        }\\n    }\\n\\n    function _verifySignature(TEESettlementData calldata settlement, address expectedSigner) private pure returns (bool) {\\n        bytes calldata signature = settlement.signature;\\n        if (signature.length != 65) return false;\\n        \\n        bytes32 messageHash = keccak256(abi.encodePacked(\\n            settlement.requestsHash,\\n            settlement.nonce,\\n            settlement.provider,\\n            settlement.user,\\n            settlement.totalFee\\n        ));\\n        \\n        bytes32 ethSignedHash = keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", messageHash));\\n        \\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n        \\n        assembly {\\n            r := calldataload(add(signature.offset, 0))\\n            s := calldataload(add(signature.offset, 32))\\n            v := byte(0, calldataload(add(signature.offset, 64)))\\n        }\\n        \\n        if (v < 27) v += 27;\\n        \\n        return ecrecover(ethSignedHash, v, r, s) == expectedSigner;\\n    }\\n\\n    function _recordFailure(\\n        address[] memory failedUsers,\\n        SettlementStatus[] memory failureReasons,\\n        uint index,\\n        address user,\\n        SettlementStatus reason\\n    ) private pure {\\n        failedUsers[index] = user;\\n        failureReasons[index] = reason;\\n    }\\n\\n    function _recordPartial(\\n        address[] memory partialUsers,\\n        uint256[] memory partialAmounts,\\n        uint index,\\n        address user,\\n        uint256 amount\\n    ) private pure {\\n        partialUsers[index] = user;\\n        partialAmounts[index] = amount;\\n    }\\n\\n    // === ERC165 Support ===\\n    \\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return\\n            interfaceId == type(IServing).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    receive() external payable {\\n        revert(\\\"Direct deposits disabled; use LedgerManager\\\");\\n    }\\n}\\n\",\"keccak256\":\"0x340072a7450286fbd41dfe17df73efcbaaf7b22486d7d0bad343b72c6029864a\",\"license\":\"MIT\"},\"contracts/ledger/LedgerManager.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\nimport \\\"../utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\ninterface IServing {\\n    function accountExists(address user, address provider) external view returns (bool);\\n    function getPendingRefund(address user, address provider) external view returns (uint);\\n    function addAccount(address user, address provider, string memory additionalInfo) external payable;\\n    function depositFund(address user, address provider, uint cancelRetrievingAmount) external payable;\\n    function requestRefundAll(address user, address provider) external;\\n    function processRefund(address user, address provider) external returns (uint totalAmount, uint balance, uint pendingRefund);\\n    function deleteAccount(address user, address provider) external;\\n}\\n\\n// Simplified ledger structure\\nstruct Ledger {\\n    address user;\\n    uint availableBalance;\\n    uint totalBalance;\\n    string additionalInfo;\\n}\\n\\n// Service information structure\\nstruct ServiceInfo {\\n    address serviceAddress;\\n    IServing serviceContract;\\n    string serviceType; // \\\"inference\\\" or \\\"fine-tuning\\\"\\n    string version;     // \\\"v1.0\\\", \\\"v2.0\\\" etc.\\n    string fullName;    // \\\"inference-v2.0\\\"\\n    string description;\\n    bool isRecommended; // Whether this is the recommended version for this service type\\n    uint256 registeredAt;\\n}\\n\\ninterface ILedger {\\n    function spendFund(address user, uint amount) external;\\n    function depositFundFor(address recipient) external payable;\\n}\\n\\n\\ncontract LedgerManager is Ownable, Initializable, ReentrancyGuard {\\n    using EnumerableSet for EnumerableSet.Bytes32Set;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using ERC165Checker for address;\\n\\n    // @custom:storage-location erc7201:0g.serving.ledger\\n    struct LedgerManagerStorage {\\n        // Service registry (using address as key)\\n        mapping(address => ServiceInfo) registeredServices;\\n        mapping(string => address) serviceNameToAddress; // \\\"inference-v2.0\\\" => address\\n        EnumerableSet.AddressSet serviceAddresses;\\n        mapping(bytes32 => address) recommendedByType; // per-type recommended service pointer\\n        \\n        LedgerMap ledgerMap;\\n        mapping(address => mapping(string => EnumerableSet.AddressSet)) userServiceProviders; // user => serviceType => providers\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"0g.serving.ledger\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant LEDGER_MANAGER_STORAGE_LOCATION = 0x0bb5d42557ea6926c17416c5b1c1c29c28d9006d6f713295a2d385f07156ed00;\\n\\n    function _getLedgerManagerStorage() private pure returns (LedgerManagerStorage storage $) {\\n        assembly {\\n            $.slot := LEDGER_MANAGER_STORAGE_LOCATION\\n        }\\n    }\\n\\n    // Constants\\n    uint public constant MAX_PROVIDERS_PER_BATCH = 20;\\n    uint public constant MAX_SERVICES = 500;\\n    uint public constant MAX_ADDITIONAL_INFO_LENGTH = 4096; // 4KB limit for JSON configuration data\\n    uint public constant MIN_ACCOUNT_BALANCE = 3 ether; // 3 0G minimum account balance\\n    uint public constant MIN_TRANSFER_AMOUNT = 1 ether; // 1 0G minimum transfer for new service account\\n    bytes4 private constant SERVING_INTERFACE_ID = type(IServing).interfaceId;\\n\\n    // Events\\n    event ServiceRegistered(address indexed serviceAddress, string serviceName);\\n    event RecommendedServiceUpdated(string indexed serviceType, string version, address serviceAddress);\\n\\n    // Errors\\n    error LedgerNotExists(address user);\\n    error LedgerExists(address user);\\n    error InsufficientBalance(address user);\\n    error TooManyProviders(uint requested, uint maximum);\\n    error InvalidServiceType(string serviceType);\\n    error ServiceNotRegistered(address serviceAddress);\\n    error ServiceNameExists(string serviceName);\\n    error InvalidServiceAddress(address serviceAddress);\\n\\n    struct LedgerMap {\\n        EnumerableSet.Bytes32Set _keys;\\n        mapping(bytes32 => Ledger) _values;\\n        // Operation locks to prevent reentrancy\\n        mapping(bytes32 => bool) _operationLocks;\\n    }\\n\\n    // Prevent reentrancy on ledger operations\\n    modifier withLedgerLock(address user) {\\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\\n        bytes32 key = _key(user);\\n        require(!$.ledgerMap._operationLocks[key], \\\"Ledger locked for operation\\\");\\n        $.ledgerMap._operationLocks[key] = true;\\n        _;\\n        $.ledgerMap._operationLocks[key] = false;\\n    }\\n\\n    function initialize(\\n        address owner\\n    ) public onlyInitializeOnce {\\n        _transferOwnership(owner);\\n    }\\n\\n    modifier onlyServing() {\\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\\n        require(\\n            $.registeredServices[msg.sender].serviceAddress != address(0),\\n            \\\"Caller is not a registered service\\\"\\n        );\\n        _;\\n    }\\n\\n    function getLedger(address user) public view returns (Ledger memory) {\\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\\n        return _get($, user);\\n    }\\n\\n    function getAllLedgers(uint offset, uint limit) public view returns (Ledger[] memory ledgers, uint total) {\\n        total = _length();\\n\\n        if (offset >= total) {\\n            return (new Ledger[](0), total);\\n        }\\n\\n        uint end = Math.min(offset + (limit == 0 ? 50 : limit), total);\\n        uint resultLen = end - offset;\\n        ledgers = new Ledger[](resultLen);\\n\\n        for (uint i = 0; i < resultLen; i++) {\\n            ledgers[i] = _at(offset + i);\\n        }\\n\\n        return (ledgers, total);\\n    }\\n\\n    // Get providers for a specific user and service\\n    function getLedgerProviders(address user, string memory serviceName) public view returns (address[] memory) {\\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\\n        address serviceAddress = $.serviceNameToAddress[serviceName];\\n        require(serviceAddress != address(0), \\\"Service not found\\\");\\n        \\n        string memory serviceType = $.registeredServices[serviceAddress].serviceType;\\n        EnumerableSet.AddressSet storage providers = $.userServiceProviders[user][serviceType];\\n        address[] memory providerList = new address[](providers.length());\\n        \\n        for (uint256 i = 0; i < providers.length(); i++) {\\n            providerList[i] = providers.at(i);\\n        }\\n        \\n        return providerList;\\n    }\\n\\n    function addLedger(string memory additionalInfo) external payable withLedgerLock(msg.sender) returns (uint, uint) {\\n        require(msg.value >= MIN_ACCOUNT_BALANCE, \\\"Minimum deposit of 3 0G required\\\");\\n        require(bytes(additionalInfo).length <= MAX_ADDITIONAL_INFO_LENGTH, \\\"Additional info exceeds 4KB limit\\\");\\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\\n        bytes32 key = _key(msg.sender);\\n        if (_contains($, key)) {\\n            revert LedgerExists(msg.sender);\\n        }\\n        _set($, key, msg.sender, msg.value, additionalInfo);\\n        return (msg.value, 0);\\n    }\\n\\n    function depositFund() external payable withLedgerLock(msg.sender) {\\n        _depositFundInternal(msg.sender, msg.value);\\n    }\\n    \\n    // Internal function for deposit logic without modifier\\n    function _depositFundInternal(address user, uint256 amount) internal {\\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\\n        bytes32 key = _key(user);\\n        \\n        // Create account if it doesn't exist\\n        if (!_contains($, key)) {\\n            require(amount >= MIN_ACCOUNT_BALANCE, \\\"Minimum deposit of 3 0G required for new account\\\");\\n            _set($, key, user, amount, \\\"\\\");\\n        } else {\\n            Ledger storage ledger = $.ledgerMap._values[key];\\n            ledger.availableBalance += amount;\\n            ledger.totalBalance += amount;\\n        }\\n    }\\n\\n    function depositFundFor(address recipient) external payable withLedgerLock(recipient) {\\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\\n        bytes32 key = _key(recipient);\\n        \\n        // Create account if it doesn't exist\\n        if (!_contains($, key)) {\\n            require(msg.value > 0, \\\"Zero-value creation not allowed\\\");\\n            _set($, key, recipient, msg.value, \\\"\\\");\\n        } else {\\n            Ledger storage ledger = $.ledgerMap._values[key];\\n            ledger.availableBalance += msg.value;\\n            ledger.totalBalance += msg.value;\\n        }\\n    }\\n\\n    function refund(uint amount) external withLedgerLock(msg.sender) {\\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\\n        Ledger storage ledger = _get($, msg.sender);\\n        if (ledger.availableBalance < amount) {\\n            revert InsufficientBalance(msg.sender);\\n        }\\n\\n        // Enforce minimum balance: must keep MIN_ACCOUNT_BALANCE or withdraw all\\n        uint remainingBalance = ledger.availableBalance - amount;\\n        require(\\n            remainingBalance == 0 || remainingBalance >= MIN_ACCOUNT_BALANCE,\\n            \\\"Must maintain minimum balance of 3 0G or withdraw all funds\\\"\\n        );\\n\\n        ledger.availableBalance -= amount;\\n        ledger.totalBalance -= amount;\\n        (bool success, ) = payable(msg.sender).call{value: amount}(\\\"\\\");\\n        require(success, \\\"0G transfer failed\\\");\\n\\n        // Auto-delete account if total balance reaches 0\\n        if (ledger.totalBalance == 0) {\\n            _deleteAllServiceAccounts($, msg.sender);\\n            bytes32 key = _key(msg.sender);\\n            $.ledgerMap._keys.remove(key);\\n            delete $.ledgerMap._values[key];\\n        }\\n    }\\n\\n    // Enhanced transferFund with dynamic service support\\n    function transferFund(\\n        address provider,\\n        string memory serviceName,\\n        uint amount\\n    ) external withLedgerLock(msg.sender) {\\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\\n        Ledger storage ledger = _get($, msg.sender);\\n        \\n        // Dynamic service lookup\\n        address serviceAddress = $.serviceNameToAddress[serviceName];\\n        require(serviceAddress != address(0), \\\"Service not found\\\");\\n        \\n        ServiceInfo storage service = $.registeredServices[serviceAddress];\\n        \\n        address servingAddress = service.serviceAddress;\\n        IServing serving = service.serviceContract;\\n\\n        uint transferAmount = amount;\\n        bytes memory payload;\\n\\n        if (serving.accountExists(msg.sender, provider)) {\\n            // Account exists - handle pending refunds\\n            uint retrievingAmount = serving.getPendingRefund(msg.sender, provider);\\n            uint cancelRetrievingAmount = Math.min(amount, retrievingAmount);\\n            transferAmount -= cancelRetrievingAmount;\\n\\n            payload = abi.encodeWithSignature(\\n                \\\"depositFund(address,address,uint256)\\\",\\n                msg.sender,\\n                provider,\\n                cancelRetrievingAmount\\n            );\\n        } else {\\n            // New account - require minimum transfer amount\\n            require(amount >= MIN_TRANSFER_AMOUNT, \\\"Minimum 1 0G required for new sub account\\\");\\n\\n            // Use unified addAccount interface\\n            payload = abi.encodeWithSignature(\\n                \\\"addAccount(address,address,string)\\\",\\n                msg.sender,\\n                provider,\\n                ledger.additionalInfo\\n            );\\n            \\n            // Add provider to service storage\\n            _addProviderToService($, msg.sender, service.serviceType, provider);\\n        }\\n\\n        require(ledger.availableBalance >= transferAmount, \\\"Insufficient balance\\\");\\n        ledger.availableBalance -= transferAmount;\\n\\n        (bool success, ) = servingAddress.call{value: transferAmount}(payload);\\n        require(success, \\\"Call to child contract failed\\\");\\n    }\\n\\n    function retrieveFund(\\n        address[] memory providers,\\n        string memory serviceName\\n    ) external withLedgerLock(msg.sender) {\\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\\n        if (providers.length > MAX_PROVIDERS_PER_BATCH) {\\n            revert TooManyProviders(providers.length, MAX_PROVIDERS_PER_BATCH);\\n        }\\n\\n        // Dynamic service lookup\\n        address serviceAddress = $.serviceNameToAddress[serviceName];\\n        require(serviceAddress != address(0), \\\"Service not found\\\");\\n        \\n        ServiceInfo storage service = $.registeredServices[serviceAddress];\\n        \\n        IServing serving = service.serviceContract;\\n        \\n        Ledger storage ledger = _get($, msg.sender);\\n        uint totalAmount = 0;\\n\\n        for (uint i = 0; i < providers.length; i++) {\\n            if (serving.accountExists(msg.sender, providers[i])) {\\n                (uint amount, , ) = serving.processRefund(msg.sender, providers[i]);\\n                totalAmount += amount;\\n                serving.requestRefundAll(msg.sender, providers[i]);\\n            }\\n        }\\n        ledger.availableBalance += totalAmount;\\n    }\\n\\n    function deleteLedger() external nonReentrant withLedgerLock(msg.sender) {\\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\\n        Ledger storage ledger = _get($, msg.sender);\\n        \\n        // Safety check: ensure all funds have been withdrawn\\n        require(ledger.totalBalance == 0, \\\"Must withdraw all funds first\\\");\\n        \\n        _deleteAllServiceAccounts($, msg.sender);\\n        \\n        bytes32 key = _key(msg.sender);\\n        // Delete main ledger\\n        $.ledgerMap._keys.remove(key);\\n        delete $.ledgerMap._values[key];\\n    }\\n\\n    function _deleteAllServiceAccounts(LedgerManagerStorage storage $, address user) private {\\n        // Delete all service accounts dynamically\\n        uint256 serviceCount = $.serviceAddresses.length();\\n        for (uint256 i = 0; i < serviceCount; i++) {\\n            address serviceAddress = $.serviceAddresses.at(i);\\n            ServiceInfo storage service = $.registeredServices[serviceAddress];\\n\\n            EnumerableSet.AddressSet storage providers = $.userServiceProviders[user][service.serviceType];\\n            address[] memory providerList = new address[](providers.length());\\n            for (uint j = 0; j < providers.length(); j++) {\\n                providerList[j] = providers.at(j);\\n            }\\n            \\n            for (uint j = 0; j < providerList.length; j++) {\\n                try service.serviceContract.deleteAccount(user, providerList[j]) {\\n                    providers.remove(providerList[j]);\\n                } catch {\\n                    providers.remove(providerList[j]); // Remove even on failure\\n                }\\n            }\\n        }\\n    }\\n\\n\\n    // === Service Registration Management ===\\n\\n    function registerService(\\n        string memory serviceType,\\n        string memory version,\\n        address serviceAddress,\\n        string memory description\\n    ) external onlyOwner {\\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\\n        require(serviceAddress != address(0), \\\"Invalid service address\\\");\\n        require(bytes(serviceType).length > 0, \\\"Service type required\\\");\\n        require(bytes(version).length > 0, \\\"Version required\\\");\\n        require($.registeredServices[serviceAddress].serviceAddress == address(0), \\\"Service already registered\\\");\\n        \\n        string memory fullName = string(abi.encodePacked(serviceType, \\\"-\\\", version));\\n        require($.serviceNameToAddress[fullName] == address(0), \\\"Service name already exists\\\");\\n        \\n        // Check interface support\\n        require(\\n            serviceAddress.supportsInterface(type(IERC165).interfaceId),\\n            \\\"Service must support ERC165 interface detection\\\"\\n        );\\n        require(\\n            serviceAddress.supportsInterface(SERVING_INTERFACE_ID),\\n            \\\"Service must implement IServing interface\\\"\\n        );\\n        require(\\n            $.serviceAddresses.length() < MAX_SERVICES,\\n            \\\"Service registry limit reached\\\"\\n        );\\n        \\n        // Register service (default not recommended)\\n        $.registeredServices[serviceAddress] = ServiceInfo({\\n            serviceAddress: serviceAddress,\\n            serviceContract: IServing(serviceAddress),\\n            serviceType: serviceType,\\n            version: version,\\n            fullName: fullName,\\n            description: description,\\n            isRecommended: false, // Default not recommended\\n            registeredAt: block.timestamp\\n        });\\n        \\n        $.serviceNameToAddress[fullName] = serviceAddress;\\n        $.serviceAddresses.add(serviceAddress);\\n        \\n        emit ServiceRegistered(serviceAddress, fullName);\\n    }\\n\\n    function setRecommendedService(\\n        string memory serviceType,\\n        string memory version\\n    ) external onlyOwner {\\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\\n        string memory fullName = string(abi.encodePacked(serviceType, \\\"-\\\", version));\\n        address serviceAddress = $.serviceNameToAddress[fullName];\\n        require(serviceAddress != address(0), \\\"Service not found\\\");\\n        \\n        // Update per-type recommended pointer and clear previous recommendation if any (O(1))\\n        bytes32 tkey = keccak256(abi.encodePacked(serviceType));\\n        address old = $.recommendedByType[tkey];\\n        if (old != address(0) && old != serviceAddress) {\\n            $.registeredServices[old].isRecommended = false;\\n        }\\n        $.recommendedByType[tkey] = serviceAddress;\\n        \\n        // Set new recommended service\\n        $.registeredServices[serviceAddress].isRecommended = true;\\n        \\n        emit RecommendedServiceUpdated(serviceType, version, serviceAddress);\\n    }\\n    \\n\\n    function getServiceInfo(address serviceAddress) external view returns (ServiceInfo memory) {\\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\\n        return $.registeredServices[serviceAddress];\\n    }\\n\\n    function getServiceAddressByName(string memory serviceName) external view returns (address) {\\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\\n        return $.serviceNameToAddress[serviceName];\\n    }\\n\\n    function getAllActiveServices() external view returns (ServiceInfo[] memory) {\\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\\n        uint256 count = $.serviceAddresses.length();\\n        ServiceInfo[] memory services = new ServiceInfo[](count);\\n        \\n        for (uint256 i = 0; i < count; i++) {\\n            address serviceAddress = $.serviceAddresses.at(i);\\n            services[i] = $.registeredServices[serviceAddress];\\n        }\\n        \\n        return services;\\n    }\\n    \\n    function getRecommendedService(string memory serviceType) \\n        external view returns (string memory version, address serviceAddress) {\\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\\n        bytes32 tkey = keccak256(abi.encodePacked(serviceType));\\n        address addr = $.recommendedByType[tkey];\\n        require(addr != address(0), \\\"No recommended service found for this type\\\");\\n        \\n        ServiceInfo storage service = $.registeredServices[addr];\\n        return (service.version, addr);\\n    }\\n    \\n    function getAllVersions(string memory serviceType) \\n        external view returns (\\n            string[] memory versions,\\n            address[] memory addresses,\\n            bool[] memory isRecommendedFlags\\n        ) {\\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\\n        // First count matching services\\n        uint256 count = $.serviceAddresses.length();\\n        uint256 matchCount = 0;\\n        for (uint256 i = 0; i < count; i++) {\\n            address addr = $.serviceAddresses.at(i);\\n            ServiceInfo storage service = $.registeredServices[addr];\\n            if (keccak256(abi.encodePacked(service.serviceType)) == keccak256(abi.encodePacked(serviceType))) {\\n                matchCount++;\\n            }\\n        }\\n        \\n        // Allocate arrays\\n        versions = new string[](matchCount);\\n        addresses = new address[](matchCount);\\n        isRecommendedFlags = new bool[](matchCount);\\n        \\n        // Fill arrays\\n        uint256 index = 0;\\n        for (uint256 i = 0; i < count; i++) {\\n            address addr = $.serviceAddresses.at(i);\\n            ServiceInfo storage service = $.registeredServices[addr];\\n            if (keccak256(abi.encodePacked(service.serviceType)) == keccak256(abi.encodePacked(serviceType))) {\\n                versions[index] = service.version;\\n                addresses[index] = addr;\\n                isRecommendedFlags[index] = service.isRecommended;\\n                index++;\\n            }\\n        }\\n    }\\n    \\n    function isRecommendedVersion(string memory serviceType, string memory version)\\n        external view returns (bool) {\\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\\n        string memory fullName = string(abi.encodePacked(serviceType, \\\"-\\\", version));\\n        address serviceAddress = $.serviceNameToAddress[fullName];\\n        if (serviceAddress == address(0)) {\\n            return false;\\n        }\\n        return $.registeredServices[serviceAddress].isRecommended;\\n    }\\n\\n    function _addProviderToService(LedgerManagerStorage storage $, address user, string memory serviceType, address provider) private {\\n        EnumerableSet.AddressSet storage providers = $.userServiceProviders[user][serviceType];\\n        providers.add(provider);\\n    }\\n\\n    function spendFund(address user, uint amount) external onlyServing withLedgerLock(user) {\\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\\n        Ledger storage ledger = _get($, user);\\n        require((ledger.totalBalance - ledger.availableBalance) >= amount, \\\"Insufficient balance\\\");\\n        ledger.totalBalance -= amount;\\n    }\\n\\n    function _at(uint index) internal view returns (Ledger storage) {\\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\\n        bytes32 key = $.ledgerMap._keys.at(index);\\n        return $.ledgerMap._values[key];\\n    }\\n\\n    function _contains(LedgerManagerStorage storage $, bytes32 key) internal view returns (bool) {\\n        return $.ledgerMap._keys.contains(key);\\n    }\\n\\n    function _length() internal view returns (uint) {\\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\\n        return $.ledgerMap._keys.length();\\n    }\\n\\n    function _get(LedgerManagerStorage storage $, address user) internal view returns (Ledger storage) {\\n        bytes32 key = _key(user);\\n        if (!_contains($, key)) {\\n            revert LedgerNotExists(user);\\n        }\\n        return $.ledgerMap._values[key];\\n    }\\n\\n    // Simplified _set without signer parameter\\n    function _set(\\n        LedgerManagerStorage storage $,\\n        bytes32 key,\\n        address user,\\n        uint balance,\\n        string memory additionalInfo\\n    ) internal {\\n        Ledger storage ledger = $.ledgerMap._values[key];\\n        ledger.availableBalance = balance;\\n        ledger.totalBalance = balance;\\n        ledger.user = user;\\n        ledger.additionalInfo = additionalInfo;\\n        $.ledgerMap._keys.add(key);\\n    }\\n\\n    function _key(address user) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(user));\\n    }\\n\\n    receive() external payable {\\n        if (_isServiceContract(msg.sender)) {\\n            return;\\n        }\\n\\n        // Regular users must use depositFund() or depositFundFor() for explicit deposits\\n        revert(\\\"Direct deposits disabled; use depositFund() instead\\\");\\n    }\\n\\n    function _isServiceContract(address sender) internal view returns (bool) {\\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\\n        return $.registeredServices[sender].serviceAddress != address(0);\\n    }\\n}\\n\",\"keccak256\":\"0x5e27da7fb6fbe58232db6ce65b664b29ad62bc0f797c2868b388604203755c83\",\"license\":\"Unlicense\"},\"contracts/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.0;\\n\\ncontract Initializable {\\n    bool public initialized;\\n\\n    modifier onlyInitializeOnce() {\\n        require(!initialized, \\\"Initializable: already initialized\\\");\\n        initialized = true;\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0xbbedb4a069c359855147cd2a495235c89f42a0bf65821165c53ddb510109a9dc\",\"license\":\"GPL-3.0\"}},\"version\":1}",
  "bytecode": "0x6080806040523461005f5760008054336001600160a01b0319821681178355916001600160a01b03909116907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09080a3600180556149d190816100658239f35b600080fdfe6080604052600436101561001e575b361561001957600080fd5b614822565b60003560e01c806301ffc9a71461026e5780630d66808714610269578063147500e314610264578063158ef93e1461025f57806315a523021461025a57806317c30a03146102555780631d07cb97146102505780631d73b9f51461024b578063264173d61461024657806328b6047614610241578063398c8e4e1461023c5780633ea527cb14610237578063405a85e8146102325780634e3c4f221461022d5780634fe63f4d146102285780635bd7ace214610223578063650190e71461021e5780636c79158d14610219578063715018a614610214578063745e87f71461020f5780637ff6fc1c1461020a5780638be74119146102055780638da5cb5b1461020057806397216725146101fb578063a09cfca9146101f6578063ad6dca3f146101f1578063b2394d09146101ec578063b4988fd0146101e7578063ba16a750146101e2578063bbee42d9146101dd578063cab33d8f146101d8578063d1d20056146101d3578063ddf96abd146101ce578063e50688f9146101c9578063f2fde38b146101c4578063fbfa4e11146101bf5763fd5908470361000e57612125565b6120c4565b612033565b611dcb565b611c33565b611bfd565b611b82565b6119bf565b6118c3565b61180c565b61177d565b611760565b6116a9565b611670565b611647565b611423565b611348565b6110c3565b611065565b610f24565b610f00565b610eb1565b610e6e565b610d65565b610d10565b610cf2565b610bcc565b610a86565b610921565b6108ce565b6106c4565b6105be565b61049c565b610363565b610338565b6102d4565b346102c45760203660031901126102c45760043563ffffffff60e01b81168091036102c45760209063160841b160e01b81149081156102b3575b506040519015158152f35b6301ffc9a760e01b149050386102a8565b600080fd5b60009103126102c457565b346102c45760003660031901126102c45760206000805160206148fc83398151915254604051908152f35b6001600160a01b038116036102c457565b60409060031901126102c457600435610328816102ff565b90602435610335816102ff565b90565b346102c457602061035961035461034e36610310565b90612672565b612652565b6040519015158152f35b346102c45760003660031901126102c457602060ff60005460a01c166040519015158152f35b919082519283825260005b8481106103b5575050826000602080949584010152601f8019910116010190565b602081830181015184830182015201610394565b80516001600160a01b0316825290610335906104686104546104426104126104006020880151610160806020890152870190610389565b60408801518682036040880152610389565b606087015160608601526080870151608086015260a087015160a086015260c087015185820360c0870152610389565b60e086015184820360e0860152610389565b610100808601519084830390850152610389565b610120808501516001600160a01b03169083015292610140908101511515910152565b9060206103359281815201906103c9565b346102c45760203660031901126102c45761058a6104cd6004356104bf816102ff565b6104c7613824565b50612bed565b61057e60ff60096104dc611d5d565b84546001600160a01b03168152936104f66001820161249c565b60208601526105076002820161249c565b60408601526003810154606086015260048101546080860152600581015460a08601526105366006820161249c565b60c08601526105476007820161249c565b60e08601526105586008820161249c565b61010086015201546001600160a01b03811661012085015260a01c161515610140830152565b6040519182918261048b565b0390f35b9181601f840112156102c4578235916001600160401b0383116102c4576020808501948460051b0101116102c457565b346102c45760403660031901126102c4576004356105db816102ff565b6024356001600160401b0381116102c4576105fa90369060040161058e565b9161060581336125dd565b600a0160005b84811061068b57505060405192602090808286018387525260408501939160005b828110610666576001600160a01b038516337f70147140547b3e1660123a6725577c5574b4d40747abe6ff7c458f449e18b84f8989038aa3005b90919294828060019260ff893561067c816106b9565b1681520196019392910161062c565b80600160ff61069e6106b4948989612bd3565b356106a8816106b9565b161b8354178355612788565b61060b565b60ff8116036102c457565b346102c45760403660031901126102c4576004356106e1816102ff565b602435906106ee826106b9565b600a60ff6106fc83336125dd565b931692016001831b815417905560405191825260018060a01b0316907fcf558f061a5a4e28657b8e5c662b95b8258d880896e7a859299457be036ed4a460203392a3005b60609060031901126102c457600435610758816102ff565b906024359060443590565b90815180825260208080930193019160005b828110610783575050505090565b83518051865280830151868401526040808201519087015260609081015115159086015260809094019392810192600101610775565b80516001600160a01b03168252906020828101516001600160a01b03169082015260408201516040820152606082015160608201526080820151608082015261082661081460a08401516101608060a0860152840190610763565b60c084015183820360c0850152610389565b60e08084015115159083015291610100808201519083015261012080820151908301526101408091015191015290565b908082519081815260208091019281808460051b8301019501936000915b8483106108845750505050505090565b90919293949584806108a2600193601f198682030187528a516107b9565b9801930193019194939290610874565b9291906108c9602091604086526040860190610856565b930152565b346102c4576109006108df36610740565b8015808015610916575b6108f2906126a3565b156109105750603291612a82565b9061058a604051928392836108b2565b91612a82565b5060328211156108e9565b346102c4576020600461093c61093636610310565b906125dd565b0154604051908152f35b60206003198201126102c457600435906001600160401b0382116102c4576109709160040161058e565b9091565b90815180825260208080930193019160005b828110610994575050505090565b83516001600160a01b031685529381019392810192600101610986565b600611156109bb57565b634e487b7160e01b600052602160045260246000fd5b9060068210156109bb5752565b91906109f290608084526080840190610974565b926020938381038585015284808451928381520193019060005b818110610a625750505090610a28918382036040850152610974565b90606081830391015281808451928381520193019160005b828110610a4e575050505090565b835185529381019392810192600101610a40565b909193868082610a78600194899b9a9b516109d1565b979897019501929101610a0c565b346102c457610a9436610946565b610a9f81151561410a565b610aa881614156565b610ab182614156565b91610abb81614156565b610ac482614156565b9160008091815b818110610aef575050808552855280825282526040519450849361058a93856109de565b610afa81838b614188565b9233610b17610b0b60208701612be3565b6001600160a01b031690565b03610ba957610b258461421b565b610b308293926109b1565b8215610b9c57610b3f836109b1565b60018314610b755750610b709291610b6b91610b63610b5d82612788565b97612be3565b908c8c6147fa565b612788565b610acb565b610b7093925086610b94610b8e610b6b94989992612788565b98612be3565b908a8a614814565b50935050610b7090612788565b90610b6b82610bc4610bbe610b709592612788565b96612be3565b908b8b6147d3565b6003196020368201126102c4576004356001600160401b0381116102c457610100816004019282360301126102c4577f30ecc203691b2d18e17ee75d47caf34a3fb9f86e855f7e0414d3cec26d0c424b90610c26336129d7565b5415610c9f57610c363415613a61565b610c408333613c31565b610c7c610c9a610c508580613ac1565b9093610c5f6024820188613ac1565b949097610c6f6044840182613ac1565b9290916064850190613ac1565b949093604051988998339c4294608460a4860135950135938c613b14565b0390a2005b610cb468056bc75e2d63100000341015613a16565b34610cbe336129d7565b5560405134815233907fcd6dbb0e62eeb71e114bae8b2e2547921dd19209bebf32b595be3e7d247dbbb490602090a2610c36565b346102c45760003660031901126102c457602060405162093a808152f35b346102c45760603660031901126102c4576020600435610d2f816102ff565b600a610d52602435610d40816102ff565b60443593610d4d856106b9565b6125dd565b0154600160ff60405193161b1615158152f35b346102c457610d7336610310565b9060018060a01b03610d978160008051602061489c83398151915254163314612ccc565b610db16000805160206148fc833981519152548484613689565b9193909484610ddf575b505061058a9150604051938493846040919493926060820195825260208201520152565b600080808088335af1610df0613659565b5015610e2957604080518781526020810185905261058a9592831693909216916000805160206148bc8339815191529190a33880610dbb565b60405162461bcd60e51b815260206004820152601960248201527f7472616e7366657220746f206c6564676572206661696c6564000000000000006044820152606490fd5b346102c457610900610e7f36610740565b8015808015610ea6575b610e92906126a3565b15610ea05750603291612b52565b91612b52565b506032821115610e89565b346102c45760403660031901126102c4576024358015808015610ef5575b610ed8906126a3565b15610eec575061090060325b6004356127c6565b61090090610ee4565b506032821115610ecf565b346102c45760003660031901126102c457602060405168056bc75e2d631000008152f35b346102c457610f3236610310565b60008051602061489c833981519152546001600160a01b03929190610f5a9084163314612ccc565b610f648183613568565b610f6e81836125dd565b610f76611d5d565b81546001600160a01b0316815260018201546001600160a01b03166020820152600282015460408201526003820154606082015260048201546080820152610140600a610fc5600585016123dd565b9360a08401948552610fd96006820161249c565b60c0850152610ff8610fef600783015460ff1690565b151560e0860152565b60088101546101008501526009810154610120850152015491015251518061101c57005b6110467f54377dfdebf06f6df53fbda737d2dcd7e141f95bbfb0c1223437e856b9de3ac39161276c565b938060405193169316918061106042829190602083019252565b0390a4005b346102c4576000806003193601126110c05761107f6121f7565b80546001600160a01b03198116825581906001600160a01b03167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a380f35b80fd5b60603660031901126102c4576004356110db816102ff565b6024356110e7816102ff565b60008051602061489c83398151915254604435916001600160a01b03916111119083163314612ccc565b61111b81856125dd565b928015158061133b575b6111ab575b50906000805160206148bc833981519152916111976004600386019561115134885461275a565b80975501546111746111706007611168868b6125dd565b015460ff1690565b1590565b61119c575b83604051948594169716958360209093929193604081019481520152565b0390a3005b6111a68388612c89565b611179565b60048401805490946000946005820194929392865b86548810156112f0576111d38888613448565b5060038101956111e4875460ff1690565b6112e2576001820180548083106112a157506112126112269261120c6111709354809261277b565b9a61277b565b885460ff19166001178955975b5460ff1690565b8080611297575b1561126f57508161124e61126092611248611266958c613448565b90613464565b80611259818b613448565b5055612788565b97612788565b969493946111c0565b9050979097611282575b61126690612788565b9661128f61126691612788565b979050611279565b50828a141561122d565b829998926112b8575b50506111706112269161121f565b906112cb8a6112d2959a939b949b61277b565b905561277b565b94611226611170600098916112aa565b969550509661126690612788565b9195909493506000805160206148bc8339815191529650969196600888019180835581548110611326575b50505055909161112a565b61133090896134b0565b54905538808061131b565b5060058401541515611125565b346102c45760403660031901126102c457600435611365816102ff565b602435801591821582036102c45761137d90336125dd565b600781019260ff845416908161141b575b506113ac575b506113aa919060ff801983541691151516179055565b005b600301546113ba5738611394565b60405162461bcd60e51b815260206004820152603360248201527f43616e6e6f74207265766f6b652061636b6e6f776c656467656d656e742077696044820152727468206e6f6e2d7a65726f2062616c616e636560681b6064820152608490fd5b90503861138e565b346102c45761143136610946565b61143c81151561410a565b61144960328211156141aa565b61145281614156565b9061145c81614156565b9261146682614156565b9161147081614156565b91600080918193825b8181106114d35750505080865286528084528252801580156114a8575b505061058a91604051948594856109de565b6000808093819382906114ca575b3390f1156114c5573880611496565b61420f565b506108fc6114b6565b6114e1818385989698614188565b93898b336114f4610b0b60208a01612be3565b036115d357976115109861150788614318565b909b919561275a565b9961151d610b0b8a612be3565b7f1f69e5b87fd0ce34b3760ba6e5d8aa95a36e316c3ba44e1e65a9d0eb9e96d0bf6040518061154d858a836141f6565b0390a2611559856109b1565b84156115c457611568856109b1565b6001851461159a57509181610b6b9361158f61158961159598979593612788565b9a612be3565b926147fa565b611479565b9197989050611595949350610b6b92506115bc6115b682612788565b99612be3565b908b8d614814565b50509550505061159590612788565b95906115f990896115e961159596959b91612788565b986115f385612be3565b926147d3565b7f1f69e5b87fd0ce34b3760ba6e5d8aa95a36e316c3ba44e1e65a9d0eb9e96d0bf61162382612be3565b60408051600281529381013560208501526001600160a01b039190911692a2612788565b346102c45760003660031901126102c4576000546040516001600160a01b039091168152602090f35b346102c4576113aa61168136610310565b906116a460018060a01b0360008051602061489c83398151915254163314612ccc565b613051565b346102c45760403660031901126102c4576024358015808015611755575b6116d0906126a3565b1561174c57506116e460325b600435613979565b90604051906040820192604083528151809452606083019160608560051b850101926020809201906000905b878210611724575050508380955001520390f35b909194838061173f600193605f198b820301865289516103c9565b9701920192019091611710565b6116e4906116dc565b5060328211156116c7565b346102c45760003660031901126102c4576020604051610e108152f35b346102c45760203660031901126102c457600960043561179c816102ff565b6117a46121f7565b7f4909107c46469d21135443e891c6ecae55b5baa31b338d50f391935308b08f8960206117d083612bed565b846117da85612bed565b01805460ff60a01b1916600160a01b17905590930154604051600181526001600160a01b0391821694939091169290a3005b346102c45760603660031901126102c457602435611829816102ff565b604435611835816102ff565b6000549160ff8360a01c166118625760ff60a01b19909216600160a01b176000556113aa916004356122da565b60405162461bcd60e51b815260206004820152602260248201527f496e697469616c697a61626c653a20616c726561647920696e697469616c697a604482015261195960f21b6064820152608490fd5b906020610335928181520190610856565b346102c4576118d136610946565b6101f4811161197a576118e3816126f4565b9160005b8281106118fc576040518061058a86826118b2565b6119309061191c33611917611912848888612bd3565b612be3565b612672565b61192581612652565b611935575b50612788565b6118e7565b61195961195e916000526000805160206148dc833981519152602052604060002090565b612540565b61196882876127ad565b5261197381866127ad565b503861192a565b60405162461bcd60e51b815260206004820152601e60248201527f42617463682073697a6520746f6f206c6172676520286d6178203530302900006044820152606490fd5b346102c4576000806003193601126110c057600260015414611b3d5760026001556119e933612c54565b611a0d8160005260008051602061495c833981519152602052604060002054151590565b15611b255780611a8a91835260008051602061497c83398151915260205282600960408220828155611a4160018201613008565b611a4d60028201613008565b826003820155826004820155826005820155611a6b60068201613008565b611a7760078201613008565b611a8360088201613008565b015561323d565b50611a94336129d7565b5480611acd575b50337f29d546abb6e94f4f04d5bdccb6682316f597d43776078f47e273f000e77b2a918280a2611aca60018055565b80f35b81611ad7336129d7565b55611af18280808085335af1611aeb613659565b506140c8565b60405190815233907f17f7db034d4b59fadec3e44a684cb4396ca10fd036c4e4f718bf06e99371588290602090a238611a9b565b6040516304c76d3f60e11b8152336004820152602490fd5b60405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606490fd5b346102c45760203660031901126102c457600435611b9f816102ff565b611ba981336125dd565b906000600a6009840193611bbd8554612788565b9485905501556040519182526001600160a01b03169033907f989726e0ba0fa7747d8a6618329b929bfcc4f3ac46de5930a368310944f7554790602090a3005b346102c45760003660031901126102c45760008051602061489c833981519152546040516001600160a01b039091168152602090f35b346102c45760203660031901126102c4576009600435611c52816102ff565b611c5a6121f7565b7f4909107c46469d21135443e891c6ecae55b5baa31b338d50f391935308b08f896020611c8683612bed565b84611c9085612bed565b01805460ff60a01b1916905590930154604051600081526001600160a01b0391821694939091169290a3005b634e487b7160e01b600052604160045260246000fd5b61016081019081106001600160401b03821117611cee57604052565b611cbc565b608081019081106001600160401b03821117611cee57604052565b6001600160401b038111611cee57604052565b602081019081106001600160401b03821117611cee57604052565b90601f801991011681019081106001600160401b03821117611cee57604052565b60405190611d6a82611cd2565b565b60405190611d6a82611cf3565b6001600160401b038111611cee57601f01601f191660200190565b929192611da082611d79565b91611dae6040519384611d3c565b8294818452818301116102c4578281602093846000960137010152565b60603660031901126102c457600435611de3816102ff565b60243590611df0826102ff565b6001600160401b03916044358381116102c457366023820112156102c457611e22903690602481600401359101611d94565b60008051602061489c833981519152546001600160a01b039190611e499083163314612ccc565b611e538385612672565b90611e5d82612652565b61200a5760008281526000805160206148dc83398151915260209081526040822034600382015580546001600160a01b0319166001600160a01b0389161781559197600183810180546001600160a01b0319166001600160a01b038a1617905560068401928551928311611cee578a95611ee184611edb8754612462565b87612ef5565b81601f8511600114611f7e57509280806000805160206148bc8339815191529a999794899794600897611f4e9b94611f73575b50501b916000199060031b1c19161790555b0155611f3181612d40565b50611f4481611f3f87612a10565b612e57565b50611f3f86612a49565b50611f598385612c89565b60408051348152600060208201529382169490911692a380f35b015192503880611f14565b9190601f949394198416611f9787600052602060002090565b9389905b828210611ff0575050926008959285926000805160206148bc8339815191529c9b9996611f4e9b999610611fd7575b505050811b019055611f26565b015160001960f88460031b161c19169055388080611fca565b8385015186558f9a50948701949384019390810190611f9b565b604051632cf0675960e21b81526001600160a01b03868116600483015285166024820152604490fd5b346102c45760203660031901126102c457600435612050816102ff565b6120586121f7565b6001600160a01b03811615612070576113aa9061224f565b60405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b6064820152608490fd5b346102c45760203660031901126102c4576004356120e06121f7565b610e1081101580612107575b6120f590612296565b6000805160206148fc83398151915255005b5062093a808111156120ec565b9060206103359281815201906107b9565b346102c45761058a61214861213936610310565b90612142612371565b506125dd565b600a612152611d5d565b82546001600160a01b031681529160018101546001600160a01b0316602084015260028101546040840152600381015460608401526004810154608084015261219d600582016123dd565b60a08401526121ae6006820161249c565b60c08401526121cd6121c4600783015460ff1690565b151560e0850152565b60088101546101008401526009810154610120840152015461014082015260405191829182612114565b6000546001600160a01b0316330361220b57565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b600080546001600160a01b039283166001600160a01b03198216811783559216907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09080a3565b1561229d57565b60405162461bcd60e51b81526020600482015260156024820152746c6f636b54696d65206f7574206f662072616e676560581b6044820152606490fd5b90916122e59061224f565b610e1081101580612364575b6122fa90612296565b6000805160206148fc8339815191525560018060a01b03166bffffffffffffffffffffffff60a01b9060008051602061489c83398151915281838254161790557fdfd123095cdedb1cecbc229b30f7cf8745fb3d3951645ac4a8fa4c0895f8950291825416179055565b5062093a808111156122f1565b6040519061237e82611cd2565b81610140600091828152826020820152826040820152826060820152826080820152606060a0820152606060c08201528260e082015282610100820152826101208201520152565b6001600160401b038111611cee5760051b60200190565b9081546123e9816123c6565b926040936123f985519182611d3c565b828152809460208092019260005281600020906000935b85851061241f57505050505050565b600484600192845161243081611cf3565b86548152848701548382015260028701548682015260ff60038801541615156060820152815201930194019391612410565b90600182811c92168015612492575b602083101461247c57565b634e487b7160e01b600052602260045260246000fd5b91607f1691612471565b90604051918260008254926124b084612462565b90818452600194858116908160001461251d57506001146124da575b5050611d6a92500383611d3c565b9093915060005260209081600020936000915b818310612505575050611d6a935082010138806124cc565b855488840185015294850194879450918301916124ed565b915050611d6a94506020925060ff191682840152151560051b82010138806124cc565b90600a61254b611d5d565b83546001600160a01b031681529260018101546001600160a01b03166020850152600281015460408501526003810154606085015260048101546080850152612596600582016123dd565b60a08501526125a76006820161249c565b60c08501526125bd610fef600783015460ff1690565b600881015461010085015260098101546101208501520154610140830152565b906125e88183612672565b918260005260008051602061487c833981519152602052604060002054156126295750506000526000805160206148dc833981519152602052604060002090565b60405163023280eb60e21b81526001600160a01b03918216600482015291166024820152604490fd5b60005260008051602061487c833981519152602052604060002054151590565b604080516001600160a01b03928316602082019081529390921682820152815261269d606082611d3c565b51902090565b156126aa57565b60405162461bcd60e51b815260206004820152600f60248201526e4c696d697420746f6f206c6172676560881b6044820152606490fd5b6040516126ed81611d21565b6000815290565b906126fe826123c6565b61270b6040519182611d3c565b828152809261271c601f19916123c6565b019060005b82811061272d57505050565b602090612738612371565b82828501015201612721565b634e487b7160e01b600052601160045260246000fd5b9190820180921161276757565b612744565b60001981019190821161276757565b9190820391821161276757565b60001981146127675760010190565b634e487b7160e01b600052603260045260246000fd5b80518210156127c15760209160051b010190565b612797565b909160008051602061493c833981519152549182811015612867578381018082116127675793158385821561285d575b5050612854575b80840393841161276757612810846126f4565b9360005b81811061282057505050565b808301908184116127675761283a61195961284f93612877565b61284482896127ad565b5261192a81886127ad565b612814565b925081926127fd565b11905083386127f6565b509091506128736126e1565b9190565b60008051602061493c833981519152548110156127c1577fa543db6724dca3e06c9a739e16672b6894bb866e0b44759e50bc403282ce062701546000526000805160206148dc833981519152602052604060002090565b60008051602061491c833981519152548110156127c1577f94ce1cc9f419dbfb0d7a61a6415af9981ee3d1c02ba0de79a3c180abfae2b401015460005260008051602061497c833981519152602052604060002090565b60008051602061491c83398151915280548210156127c1576000527f94ce1cc9f419dbfb0d7a61a6415af9981ee3d1c02ba0de79a3c180abfae2b4010190600090565b60008051602061493c83398151915280548210156127c1576000527fa543db6724dca3e06c9a739e16672b6894bb866e0b44759e50bc403282ce06270190600090565b80548210156127c15760005260206000200190600090565b906129cd916129ab565b90549060031b1c90565b6001600160a01b031660009081527fdfd123095cdedb1cecbc229b30f7cf8745fb3d3951645ac4a8fa4c0895f8950b6020526040902090565b6001600160a01b031660009081527fdfd123095cdedb1cecbc229b30f7cf8745fb3d3951645ac4a8fa4c0895f895066020526040902090565b6001600160a01b031660009081527fdfd123095cdedb1cecbc229b30f7cf8745fb3d3951645ac4a8fa4c0895f895076020526040902090565b612a8e90939293612a10565b80549384831015612b3b5780612b2c5750835b82858211612b24575b612ab39161277b565b90612abd826126f4565b9260005b838110612ad057505050509190565b80612b0a611959612aed612ae7612b1f958761275a565b876129c3565b6000526000805160206148dc833981519152602052604060002090565b612b1482886127ad565b5261192a81876127ad565b612ac1565b859150612aaa565b820180831115612aa157612744565b505050604051612b4a81611d21565b600081529190565b612b5e90939293612a49565b80549384831015612b3b5780612bc45750835b82858211612bbc575b612b839161277b565b90612b8d826126f4565b9260005b838110612ba057505050509190565b80612b0a611959612aed612ae7612bb7958761275a565b612b91565b859150612b7a565b820180831115612b7157612744565b91908110156127c15760051b0190565b35610335816102ff565b612bf681612c54565b60005260008051602061497c83398151915260205260406000209060008051602061495c83398151915260205260406000205415612c32575090565b6040516304c76d3f60e11b81526001600160a01b039091166004820152602490fd5b604051602081019160018060a01b0316825260208152604081018181106001600160401b03821117611cee5760405251902090565b90612c93916125dd565b600781019081549060ff821680612cc4575b612cb6575b5060ff19166001179055565b600301546113ba5738612caa565b506000612ca5565b15612cd357565b60405162461bcd60e51b815260206004820152602160248201527f43616c6c6572206973206e6f7420746865206c656467657220636f6e747261636044820152601d60fa1b6064820152608490fd5b91612d3c9183549060031b91821b91600019901b19161790565b9055565b8060005260008051602061487c8339815191528060205260406000205415600014612dc85760008051602061493c8339815191528054600160401b811015611cee57600181018083558110156127c15783907fa543db6724dca3e06c9a739e16672b6894bb866e0b44759e50bc403282ce062701555491600052602052604060002055600190565b5050600090565b8060005260008051602061495c8339815191528060205260406000205415600014612dc85760008051602061491c8339815191528054600160401b811015611cee57600181018083558110156127c15783907f94ce1cc9f419dbfb0d7a61a6415af9981ee3d1c02ba0de79a3c180abfae2b40101555491600052602052604060002055600190565b6001810190826000528160205260406000205415600014612ec0578054600160401b811015611cee57612eab612e948260018794018555846129ab565b819391549060031b91821b91600019901b19161790565b90555491600052602052604060002055600190565b505050600090565b634e487b7160e01b600052600060045260246000fd5b818110612ee9575050565b60008155600101612ede565b9190601f8111612f0457505050565b611d6a926000526020600020906020601f840160051c83019310612f30575b601f0160051c0190612ede565b9091508190612f23565b91909182516001600160401b038111611cee57612f6181612f5b8454612462565b84612ef5565b602080601f8311600114612f9d575081929394600092612f92575b50508160011b916000199060031b1c1916179055565b015190503880612f7c565b90601f19831695612fb385600052602060002090565b926000905b888210612ff057505083600195969710612fd7575b505050811b019055565b015160001960f88460031b161c19169055388080612fcd565b80600185968294968601518155019501930190612fb8565b6130128154612462565b908161301c575050565b81601f6000931160011461302e575055565b90808391825261304d601f60208420940160051c840160018501612ede565b5555565b9061305c8183612672565b9161306683612652565b1561314f5761308083916130858361308061308b96612a10565b61339f565b50612a49565b50613095816132f2565b5060009081526000805160206148dc83398151915260205260408120818155816001820155816002820155816003820155600482818301556005820180549084815581613105575b505050806130ef6006600a9301613008565b8260078201558260088201558260098201550155565b6001600160fe1b0382168203612767578452602084209060021b8101905b818110156130dd5780613149849260036000918281558260018201558260028201550155565b01613123565b505050565b634e487b7160e01b600052603160045260246000fd5b60008051602061491c83398151915280549081156131bc57600019820191808310156127c1577f94ce1cc9f419dbfb0d7a61a6415af9981ee3d1c02ba0de79a3c180abfae2b400600091838352015555565b613154565b60008051602061493c83398151915280549081156131bc57600019820191808310156127c1577fa543db6724dca3e06c9a739e16672b6894bb866e0b44759e50bc403282ce0626600091838352015555565b80549081156131bc576000199182019161322d83836129ab565b909182549160031b1b1916905555565b600081815260008051602061495c83398151915260205260409020548015612dc85760001991818301918083116127675760008051602061491c833981519152549384019384116127675783836132bf94600096036132c5575b5050506132a261316a565b60005260008051602061495c833981519152602052604060002090565b55600190565b6132a26132e3916132db6129cd6132e995612925565b928391612925565b90612d22565b55388080613297565b600081815260008051602061487c83398151915260205260409020548015612dc85760001991818301918083116127675760008051602061493c833981519152549384019384116127675783836132bf9460009603613374575b5050506133576131c1565b60005260008051602061487c833981519152602052604060002090565b6133576132e39161338761339694612968565b90549060031b1c928391612968565b5538808061334c565b600181019180600052826020526040600020549283151560001461343f5760001992848401908582116127675780549485019485116127675760009585836133f3946132bf9803613402575b505050613213565b90600052602052604060002090565b6134266132e39161341661343694876129ab565b90549060031b1c928391876129ab565b8590600052602052604060002090565b553880806133eb565b50505050600090565b80548210156127c15760005260206000209060021b0190600090565b906134ab57818103613474575050565b600360ff8184611d6a95548555600181015460018601556002810154600286015501541691019060ff801983541691151516179055565b612ec8565b60050180545b8281116134c257505050565b815480156131bc57600019016134d88184613448565b6134ab57600360009182815582600182015582600282015501558255801561276757600019016134b6565b906134ab576003606083611d6a9451845560208101516001850155604081015160028501550151151591019060ff801983541691151516179055565b90815491600160401b831015611cee5782613562916001611d6a95018155613448565b90613503565b919061357481846125dd565b9260038401549161358b600486019384549061277b565b91821561365157600886019182549160058310156136285750506005612d3c949596019081548091106000146135fc57506135e99061356283546135cd611d6c565b9281845286602085015242604085015260006060850152613448565b6135f38154612788565b9055825461275a565b61362391613608611d6c565b9182528460208301524260408301526000606083015261353f565b6135e9565b604051639edd285f60e01b81526001600160a01b03918216600482015291166024820152604490fd5b505050509050565b3d15613684573d9061366a82611d79565b916136786040519384611d3c565b82523d6000602084013e565b606090565b90613693916125dd565b90600582019081541561381257600093600092600091825b825481101561376d576136be8184613448565b509760038901986136d08a5460ff1690565b613761576136e287600283015461275a565b4210613711576136fe61370c93926001610b6b9301549061275a565b8a5460ff1916600117909a55565b6136ab565b9661373a9199509461372c61370c939660018a01549061275a565b978187036137405750612788565b93612788565b61374e906112488388613448565b806137598187613448565b50553861192a565b50975061370c90612788565b50949250600883019180835581548082106137a2575b50505050816004600383019261379a87855461277b565b809455015591565b81906137b1600392839261277b565b106137ce57506137c190846134b0565b5490555b38808080613783565b96939592509390935b84548110156138065780610b6b886137f26138019489613448565b5001805460ff19166001179055565b6137d7565b509250929093506137c5565b50506003810154600490910154600092565b6040519061383182611cd2565b81610140600091828152606080602083015280604083015283818301528360808301528360a08301528060c08301528060e0830152610100820152826101208201520152565b90611d6a60ff6009613887611d5d565b85546001600160a01b03168152946138a16001820161249c565b60208701526138b26002820161249c565b60408701526003810154606087015260048101546080870152600581015460a08701526138e16006820161249c565b60c08701526138f26007820161249c565b60e08701526139036008820161249c565b61010087015201546001600160a01b03811661012086015260a01c161515610140840152565b90613933826123c6565b6139406040519182611d3c565b8281528092613951601f19916123c6565b019060005b82811061396257505050565b60209061396d613824565b82828501015201613956565b9160008051602061491c833981519152549182841015613a0657808401808511612767579015838282156139fc575b50506139f5575b838103908111612767576139c281613929565b9360005b8281106139d257505050565b8061283a6139eb6139e66139f0948661275a565b6128ce565b613877565b6139c6565b50816139af565b11905083386139a8565b50909150604051612b4a81611d21565b15613a1d57565b606460405162461bcd60e51b815260206004820152602060248201527f4d696e696d756d207374616b65206f66203130302030472072657175697265646044820152fd5b15613a6857565b60405162461bcd60e51b815260206004820152602b60248201527f43616e6e6f7420616464206d6f7265207374616b65207768656e20757064617460448201526a696e67207365727669636560a81b6064820152608490fd5b903590601e19813603018212156102c457018035906001600160401b0382116102c4576020019181360383136102c457565b908060209392818452848401376000828201840152601f01601f1916010190565b99979392613b649793613b39613b47936103359e9c98999560e08f8181520191613af3565b8c810360208e015291613af3565b9460408a01526060890152608088015286830360a0880152613af3565b9260c0818503910152613af3565b9092916001600160401b038111611cee57613b9181612f5b8454612462565b6000601f8211600114613bca5781929394600092613bbf5750508160011b916000199060031b1c1916179055565b013590503880612f7c565b601f19821694613bdf84600052602060002090565b91805b878110613c19575083600195969710613bff57505050811b019055565b0135600019600384901b60f8161c19169055388080612fcd565b90926020600181928686013581550194019101613be2565b60c0820190611000613c438385613ac1565b905011613f9d57613c5381612c54565b613c7a6111708260005260008051602061495c833981519152602052604060002054151590565b613ea35750613c8890612bed565b916001830191613c978361249c565b8051602080920120613cb3613cac8580613ac1565b3691611d94565b8281519101201493841594613e71575b8415613e3f575b8415613e0c575b858515613db2575b5083613d77613d6d600995613d2d613d23613d7d97613d0760e098613d0189613d9e9e613ac1565b91613b72565b608087013560038e015560a087013560048e0155860186613ac1565b9060028d01613b72565b4260058b0155613d4d613d436040860186613ac1565b9060068d01613b72565b613d67613d5d6060860186613ac1565b9060078d01613b72565b83613ac1565b9060088a01613b72565b01612be3565b930180546001600160a01b0319166001600160a01b03909416939093178355565b613da55750565b805460ff60a01b19169055565b60e091955093613d77613d6d600995613d2d613d23613d7d97613d07613ddd6008613d9e9d0161249c565b828151910120613df0613cac878b613ac1565b83815191012014159c9850509750505095505050935085613cd9565b60098601549094506001600160a01b0316613e2c610b0b60e08601612be3565b6001600160a01b03909116141593613cd1565b9350613e4d6007860161249c565b818151910120613e63613cac6060860186613ac1565b828151910120141593613cca565b9350613e7f6006860161249c565b818151910120613e95613cac6040860186613ac1565b828151910120141593613cc3565b929091613eb08280613ac1565b929091613ec06020830183613ac1565b92613ece6040820182613ac1565b9091613edd6060820182613ac1565b949095613eea9083613ac1565b97909860e08401613efa90612be3565b9a613f03611d5d565b6001600160a01b03909d168d523690613f1b92611d94565b60208c01523690613f2b92611d94565b60408a0152608081013560608a015260a0013560808901524260a08901523690613f5492611d94565b60c08701523690613f6492611d94565b60e08501523690613f7492611d94565b6101008301526001600160a01b03166101208201526000610140820152613f9a91613faf565b50565b60405163ef54fd9d60e01b8152600490fd5b6140c3610335928260005260008051602061497c8339815191526020526140a961014060096040600020614008613fec865160018060a01b031690565b82546001600160a01b0319166001600160a01b03909116178255565b614019602086015160018301612f3a565b61402a604086015160028301612f3a565b606085015160038201556080850151600482015560a0850151600582015561405960c086015160068301612f3a565b61406a60e086015160078301612f3a565b61407c61010086015160088301612f3a565b610120850151910180546001600160a01b0319166001600160a01b03909216919091178155920151151590565b815460ff60a01b191690151560a01b60ff60a01b16179055565b612dcf565b156140cf57565b60405162461bcd60e51b815260206004820152601360248201527214dd185ad9481c995d1d5c9b8819985a5b1959606a1b6044820152606490fd5b1561411157565b60405162461bcd60e51b815260206004820152601760248201527f4e6f20736574746c656d656e74732070726f76696465640000000000000000006044820152606490fd5b90614160826123c6565b61416d6040519182611d3c565b828152809261417e601f19916123c6565b0190602036910137565b91908110156127c15760051b8101359060be19813603018212156102c4570190565b156141b157565b60405162461bcd60e51b815260206004820152601d60248201527f546f6f206d616e7920736574746c656d656e747320696e2062617463680000006044820152606490fd5b6020909392919361420b8160408101966109d1565b0152565b6040513d6000823e3d90fd5b61422e61422782612be3565b33906125dd565b61423733612bed565b614248611170600784015460ff1690565b80156142ff575b80156142ea575b6142dd576002820154608084013511156142d0576009015461428590611170906001600160a01b03168461467e565b6142c4576003015460009160400135818111156142bc576142a6925061277b565b905b81156142b45760019190565b600091508190565b5050906142a8565b50906040600592013590565b5050906040600492013590565b5050906040600392013590565b5060098101546001600160a01b031615614256565b5060098101546143139060a01c60ff161590565b61424f565b61432461422782612be3565b9161432e33612bed565b61433f611170600786015460ff1690565b801561443b575b8015614426575b6144155760028401805491608085013580931015614402576009015461438090611170906001600160a01b03168661467e565b6143f05755604060038401549201359180831190816000146143ea5780935b600092156143e2576143b1925061277b565b925b82806143d2575b505082156143c9576001929190565b60009250829190565b6143db91614466565b38826143ba565b5050926143b3565b8361439f565b50509091506040600592013590600090565b5050509091506040600492013590600090565b509091506040600392013590600090565b5060098101546001600160a01b03161561434d565b50600981015461444f9060a01c60ff161590565b614346565b600160ff1b8114612767576000190190565b600391828201918254916004820192835490614482828261277b565b831161458f575b5050909192935061449b81855461277b565b84557fdfd123095cdedb1cecbc229b30f7cf8745fb3d3951645ac4a8fa4c0895f89502546144d1906001600160a01b0316610b0b565b82549091906001600160a01b031690823b156102c457604051631bb1482360e31b81526001600160a01b039290921660048301526024820152906000908290604490829084905af180156114c5576000805160206148bc833981519152926145719261454a92614576575b50546001600160a01b031690565b9354925460408051948552602085019190915233946001600160a01b031693918291820190565b0390a3565b8061458361458992611d0e565b806102c9565b3861453c565b6145a561459f836145ac9361277b565b8461277b565b809261277b565b845560058301906145bd825461276c565b600080821261465e576145d08285613448565b5090898201916145e1835460ff1690565b61465257600101805490949081811161463d575090614606614615939286549061277b565b9455805460ff19166001179055565b81156146295761462490614454565b6145bd565b50505090919293505b908392913880614489565b61464a929495935061277b565b905590614615565b50505061462490614454565b505050509091929350614632565b60ff601b9116019060ff821161276757565b60419061468e60a0820182613ac1565b92909203612ec057602091816146a78460009401612be3565b6146b082612be3565b604080516060808601358983019081526080870135602082015294811b6bffffffffffffffffffffffff199081168685015293901b90921660548401529290920135606882015281608882010391614710601f1993848101835282611d3c565b5190209061475f60405191826147538882019586603c917f19457468657265756d205369676e6564204d6573736167653a0a3332000000008252601c8201520190565b03908101835282611d3c565b519020906040810135831a90601b82106147be575b6040805193845260ff9092166020840152803591830191909152830135606082015280608081015b838052039060015afa156114c5576000516001600160a01b0390811691161490565b906147cb61479c9161466c565b919050614774565b906002936147e5846147f795946127ad565b6001600160a01b0390911690526127ad565b52565b926147e583614808956127ad565b60068210156109bb5752565b926147e5836147f7956127ad565b60405162461bcd60e51b815260206004820152602b60248201527f446972656374206465706f736974732064697361626c65643b20757365204c6560448201526a3233b2b926b0b730b3b2b960a91b6064820152608490fdfedfd123095cdedb1cecbc229b30f7cf8745fb3d3951645ac4a8fa4c0895f89504dfd123095cdedb1cecbc229b30f7cf8745fb3d3951645ac4a8fa4c0895f89501526824944047da5b81071fb6349412005c5da81380b336103fbe5dd34556c776dfd123095cdedb1cecbc229b30f7cf8745fb3d3951645ac4a8fa4c0895f89505dfd123095cdedb1cecbc229b30f7cf8745fb3d3951645ac4a8fa4c0895f89500dfd123095cdedb1cecbc229b30f7cf8745fb3d3951645ac4a8fa4c0895f89508dfd123095cdedb1cecbc229b30f7cf8745fb3d3951645ac4a8fa4c0895f89503dfd123095cdedb1cecbc229b30f7cf8745fb3d3951645ac4a8fa4c0895f89509dfd123095cdedb1cecbc229b30f7cf8745fb3d3951645ac4a8fa4c0895f8950aa2646970667358221220b823df78158f1f2bfcfff63c3d7117232a8b2f20c39460d72d0698cb5e0a22ad64736f6c63430008140033",
  "deployedBytecode": "0x6080604052600436101561001e575b361561001957600080fd5b614822565b60003560e01c806301ffc9a71461026e5780630d66808714610269578063147500e314610264578063158ef93e1461025f57806315a523021461025a57806317c30a03146102555780631d07cb97146102505780631d73b9f51461024b578063264173d61461024657806328b6047614610241578063398c8e4e1461023c5780633ea527cb14610237578063405a85e8146102325780634e3c4f221461022d5780634fe63f4d146102285780635bd7ace214610223578063650190e71461021e5780636c79158d14610219578063715018a614610214578063745e87f71461020f5780637ff6fc1c1461020a5780638be74119146102055780638da5cb5b1461020057806397216725146101fb578063a09cfca9146101f6578063ad6dca3f146101f1578063b2394d09146101ec578063b4988fd0146101e7578063ba16a750146101e2578063bbee42d9146101dd578063cab33d8f146101d8578063d1d20056146101d3578063ddf96abd146101ce578063e50688f9146101c9578063f2fde38b146101c4578063fbfa4e11146101bf5763fd5908470361000e57612125565b6120c4565b612033565b611dcb565b611c33565b611bfd565b611b82565b6119bf565b6118c3565b61180c565b61177d565b611760565b6116a9565b611670565b611647565b611423565b611348565b6110c3565b611065565b610f24565b610f00565b610eb1565b610e6e565b610d65565b610d10565b610cf2565b610bcc565b610a86565b610921565b6108ce565b6106c4565b6105be565b61049c565b610363565b610338565b6102d4565b346102c45760203660031901126102c45760043563ffffffff60e01b81168091036102c45760209063160841b160e01b81149081156102b3575b506040519015158152f35b6301ffc9a760e01b149050386102a8565b600080fd5b60009103126102c457565b346102c45760003660031901126102c45760206000805160206148fc83398151915254604051908152f35b6001600160a01b038116036102c457565b60409060031901126102c457600435610328816102ff565b90602435610335816102ff565b90565b346102c457602061035961035461034e36610310565b90612672565b612652565b6040519015158152f35b346102c45760003660031901126102c457602060ff60005460a01c166040519015158152f35b919082519283825260005b8481106103b5575050826000602080949584010152601f8019910116010190565b602081830181015184830182015201610394565b80516001600160a01b0316825290610335906104686104546104426104126104006020880151610160806020890152870190610389565b60408801518682036040880152610389565b606087015160608601526080870151608086015260a087015160a086015260c087015185820360c0870152610389565b60e086015184820360e0860152610389565b610100808601519084830390850152610389565b610120808501516001600160a01b03169083015292610140908101511515910152565b9060206103359281815201906103c9565b346102c45760203660031901126102c45761058a6104cd6004356104bf816102ff565b6104c7613824565b50612bed565b61057e60ff60096104dc611d5d565b84546001600160a01b03168152936104f66001820161249c565b60208601526105076002820161249c565b60408601526003810154606086015260048101546080860152600581015460a08601526105366006820161249c565b60c08601526105476007820161249c565b60e08601526105586008820161249c565b61010086015201546001600160a01b03811661012085015260a01c161515610140830152565b6040519182918261048b565b0390f35b9181601f840112156102c4578235916001600160401b0383116102c4576020808501948460051b0101116102c457565b346102c45760403660031901126102c4576004356105db816102ff565b6024356001600160401b0381116102c4576105fa90369060040161058e565b9161060581336125dd565b600a0160005b84811061068b57505060405192602090808286018387525260408501939160005b828110610666576001600160a01b038516337f70147140547b3e1660123a6725577c5574b4d40747abe6ff7c458f449e18b84f8989038aa3005b90919294828060019260ff893561067c816106b9565b1681520196019392910161062c565b80600160ff61069e6106b4948989612bd3565b356106a8816106b9565b161b8354178355612788565b61060b565b60ff8116036102c457565b346102c45760403660031901126102c4576004356106e1816102ff565b602435906106ee826106b9565b600a60ff6106fc83336125dd565b931692016001831b815417905560405191825260018060a01b0316907fcf558f061a5a4e28657b8e5c662b95b8258d880896e7a859299457be036ed4a460203392a3005b60609060031901126102c457600435610758816102ff565b906024359060443590565b90815180825260208080930193019160005b828110610783575050505090565b83518051865280830151868401526040808201519087015260609081015115159086015260809094019392810192600101610775565b80516001600160a01b03168252906020828101516001600160a01b03169082015260408201516040820152606082015160608201526080820151608082015261082661081460a08401516101608060a0860152840190610763565b60c084015183820360c0850152610389565b60e08084015115159083015291610100808201519083015261012080820151908301526101408091015191015290565b908082519081815260208091019281808460051b8301019501936000915b8483106108845750505050505090565b90919293949584806108a2600193601f198682030187528a516107b9565b9801930193019194939290610874565b9291906108c9602091604086526040860190610856565b930152565b346102c4576109006108df36610740565b8015808015610916575b6108f2906126a3565b156109105750603291612a82565b9061058a604051928392836108b2565b91612a82565b5060328211156108e9565b346102c4576020600461093c61093636610310565b906125dd565b0154604051908152f35b60206003198201126102c457600435906001600160401b0382116102c4576109709160040161058e565b9091565b90815180825260208080930193019160005b828110610994575050505090565b83516001600160a01b031685529381019392810192600101610986565b600611156109bb57565b634e487b7160e01b600052602160045260246000fd5b9060068210156109bb5752565b91906109f290608084526080840190610974565b926020938381038585015284808451928381520193019060005b818110610a625750505090610a28918382036040850152610974565b90606081830391015281808451928381520193019160005b828110610a4e575050505090565b835185529381019392810192600101610a40565b909193868082610a78600194899b9a9b516109d1565b979897019501929101610a0c565b346102c457610a9436610946565b610a9f81151561410a565b610aa881614156565b610ab182614156565b91610abb81614156565b610ac482614156565b9160008091815b818110610aef575050808552855280825282526040519450849361058a93856109de565b610afa81838b614188565b9233610b17610b0b60208701612be3565b6001600160a01b031690565b03610ba957610b258461421b565b610b308293926109b1565b8215610b9c57610b3f836109b1565b60018314610b755750610b709291610b6b91610b63610b5d82612788565b97612be3565b908c8c6147fa565b612788565b610acb565b610b7093925086610b94610b8e610b6b94989992612788565b98612be3565b908a8a614814565b50935050610b7090612788565b90610b6b82610bc4610bbe610b709592612788565b96612be3565b908b8b6147d3565b6003196020368201126102c4576004356001600160401b0381116102c457610100816004019282360301126102c4577f30ecc203691b2d18e17ee75d47caf34a3fb9f86e855f7e0414d3cec26d0c424b90610c26336129d7565b5415610c9f57610c363415613a61565b610c408333613c31565b610c7c610c9a610c508580613ac1565b9093610c5f6024820188613ac1565b949097610c6f6044840182613ac1565b9290916064850190613ac1565b949093604051988998339c4294608460a4860135950135938c613b14565b0390a2005b610cb468056bc75e2d63100000341015613a16565b34610cbe336129d7565b5560405134815233907fcd6dbb0e62eeb71e114bae8b2e2547921dd19209bebf32b595be3e7d247dbbb490602090a2610c36565b346102c45760003660031901126102c457602060405162093a808152f35b346102c45760603660031901126102c4576020600435610d2f816102ff565b600a610d52602435610d40816102ff565b60443593610d4d856106b9565b6125dd565b0154600160ff60405193161b1615158152f35b346102c457610d7336610310565b9060018060a01b03610d978160008051602061489c83398151915254163314612ccc565b610db16000805160206148fc833981519152548484613689565b9193909484610ddf575b505061058a9150604051938493846040919493926060820195825260208201520152565b600080808088335af1610df0613659565b5015610e2957604080518781526020810185905261058a9592831693909216916000805160206148bc8339815191529190a33880610dbb565b60405162461bcd60e51b815260206004820152601960248201527f7472616e7366657220746f206c6564676572206661696c6564000000000000006044820152606490fd5b346102c457610900610e7f36610740565b8015808015610ea6575b610e92906126a3565b15610ea05750603291612b52565b91612b52565b506032821115610e89565b346102c45760403660031901126102c4576024358015808015610ef5575b610ed8906126a3565b15610eec575061090060325b6004356127c6565b61090090610ee4565b506032821115610ecf565b346102c45760003660031901126102c457602060405168056bc75e2d631000008152f35b346102c457610f3236610310565b60008051602061489c833981519152546001600160a01b03929190610f5a9084163314612ccc565b610f648183613568565b610f6e81836125dd565b610f76611d5d565b81546001600160a01b0316815260018201546001600160a01b03166020820152600282015460408201526003820154606082015260048201546080820152610140600a610fc5600585016123dd565b9360a08401948552610fd96006820161249c565b60c0850152610ff8610fef600783015460ff1690565b151560e0860152565b60088101546101008501526009810154610120850152015491015251518061101c57005b6110467f54377dfdebf06f6df53fbda737d2dcd7e141f95bbfb0c1223437e856b9de3ac39161276c565b938060405193169316918061106042829190602083019252565b0390a4005b346102c4576000806003193601126110c05761107f6121f7565b80546001600160a01b03198116825581906001600160a01b03167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a380f35b80fd5b60603660031901126102c4576004356110db816102ff565b6024356110e7816102ff565b60008051602061489c83398151915254604435916001600160a01b03916111119083163314612ccc565b61111b81856125dd565b928015158061133b575b6111ab575b50906000805160206148bc833981519152916111976004600386019561115134885461275a565b80975501546111746111706007611168868b6125dd565b015460ff1690565b1590565b61119c575b83604051948594169716958360209093929193604081019481520152565b0390a3005b6111a68388612c89565b611179565b60048401805490946000946005820194929392865b86548810156112f0576111d38888613448565b5060038101956111e4875460ff1690565b6112e2576001820180548083106112a157506112126112269261120c6111709354809261277b565b9a61277b565b885460ff19166001178955975b5460ff1690565b8080611297575b1561126f57508161124e61126092611248611266958c613448565b90613464565b80611259818b613448565b5055612788565b97612788565b969493946111c0565b9050979097611282575b61126690612788565b9661128f61126691612788565b979050611279565b50828a141561122d565b829998926112b8575b50506111706112269161121f565b906112cb8a6112d2959a939b949b61277b565b905561277b565b94611226611170600098916112aa565b969550509661126690612788565b9195909493506000805160206148bc8339815191529650969196600888019180835581548110611326575b50505055909161112a565b61133090896134b0565b54905538808061131b565b5060058401541515611125565b346102c45760403660031901126102c457600435611365816102ff565b602435801591821582036102c45761137d90336125dd565b600781019260ff845416908161141b575b506113ac575b506113aa919060ff801983541691151516179055565b005b600301546113ba5738611394565b60405162461bcd60e51b815260206004820152603360248201527f43616e6e6f74207265766f6b652061636b6e6f776c656467656d656e742077696044820152727468206e6f6e2d7a65726f2062616c616e636560681b6064820152608490fd5b90503861138e565b346102c45761143136610946565b61143c81151561410a565b61144960328211156141aa565b61145281614156565b9061145c81614156565b9261146682614156565b9161147081614156565b91600080918193825b8181106114d35750505080865286528084528252801580156114a8575b505061058a91604051948594856109de565b6000808093819382906114ca575b3390f1156114c5573880611496565b61420f565b506108fc6114b6565b6114e1818385989698614188565b93898b336114f4610b0b60208a01612be3565b036115d357976115109861150788614318565b909b919561275a565b9961151d610b0b8a612be3565b7f1f69e5b87fd0ce34b3760ba6e5d8aa95a36e316c3ba44e1e65a9d0eb9e96d0bf6040518061154d858a836141f6565b0390a2611559856109b1565b84156115c457611568856109b1565b6001851461159a57509181610b6b9361158f61158961159598979593612788565b9a612be3565b926147fa565b611479565b9197989050611595949350610b6b92506115bc6115b682612788565b99612be3565b908b8d614814565b50509550505061159590612788565b95906115f990896115e961159596959b91612788565b986115f385612be3565b926147d3565b7f1f69e5b87fd0ce34b3760ba6e5d8aa95a36e316c3ba44e1e65a9d0eb9e96d0bf61162382612be3565b60408051600281529381013560208501526001600160a01b039190911692a2612788565b346102c45760003660031901126102c4576000546040516001600160a01b039091168152602090f35b346102c4576113aa61168136610310565b906116a460018060a01b0360008051602061489c83398151915254163314612ccc565b613051565b346102c45760403660031901126102c4576024358015808015611755575b6116d0906126a3565b1561174c57506116e460325b600435613979565b90604051906040820192604083528151809452606083019160608560051b850101926020809201906000905b878210611724575050508380955001520390f35b909194838061173f600193605f198b820301865289516103c9565b9701920192019091611710565b6116e4906116dc565b5060328211156116c7565b346102c45760003660031901126102c4576020604051610e108152f35b346102c45760203660031901126102c457600960043561179c816102ff565b6117a46121f7565b7f4909107c46469d21135443e891c6ecae55b5baa31b338d50f391935308b08f8960206117d083612bed565b846117da85612bed565b01805460ff60a01b1916600160a01b17905590930154604051600181526001600160a01b0391821694939091169290a3005b346102c45760603660031901126102c457602435611829816102ff565b604435611835816102ff565b6000549160ff8360a01c166118625760ff60a01b19909216600160a01b176000556113aa916004356122da565b60405162461bcd60e51b815260206004820152602260248201527f496e697469616c697a61626c653a20616c726561647920696e697469616c697a604482015261195960f21b6064820152608490fd5b906020610335928181520190610856565b346102c4576118d136610946565b6101f4811161197a576118e3816126f4565b9160005b8281106118fc576040518061058a86826118b2565b6119309061191c33611917611912848888612bd3565b612be3565b612672565b61192581612652565b611935575b50612788565b6118e7565b61195961195e916000526000805160206148dc833981519152602052604060002090565b612540565b61196882876127ad565b5261197381866127ad565b503861192a565b60405162461bcd60e51b815260206004820152601e60248201527f42617463682073697a6520746f6f206c6172676520286d6178203530302900006044820152606490fd5b346102c4576000806003193601126110c057600260015414611b3d5760026001556119e933612c54565b611a0d8160005260008051602061495c833981519152602052604060002054151590565b15611b255780611a8a91835260008051602061497c83398151915260205282600960408220828155611a4160018201613008565b611a4d60028201613008565b826003820155826004820155826005820155611a6b60068201613008565b611a7760078201613008565b611a8360088201613008565b015561323d565b50611a94336129d7565b5480611acd575b50337f29d546abb6e94f4f04d5bdccb6682316f597d43776078f47e273f000e77b2a918280a2611aca60018055565b80f35b81611ad7336129d7565b55611af18280808085335af1611aeb613659565b506140c8565b60405190815233907f17f7db034d4b59fadec3e44a684cb4396ca10fd036c4e4f718bf06e99371588290602090a238611a9b565b6040516304c76d3f60e11b8152336004820152602490fd5b60405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606490fd5b346102c45760203660031901126102c457600435611b9f816102ff565b611ba981336125dd565b906000600a6009840193611bbd8554612788565b9485905501556040519182526001600160a01b03169033907f989726e0ba0fa7747d8a6618329b929bfcc4f3ac46de5930a368310944f7554790602090a3005b346102c45760003660031901126102c45760008051602061489c833981519152546040516001600160a01b039091168152602090f35b346102c45760203660031901126102c4576009600435611c52816102ff565b611c5a6121f7565b7f4909107c46469d21135443e891c6ecae55b5baa31b338d50f391935308b08f896020611c8683612bed565b84611c9085612bed565b01805460ff60a01b1916905590930154604051600081526001600160a01b0391821694939091169290a3005b634e487b7160e01b600052604160045260246000fd5b61016081019081106001600160401b03821117611cee57604052565b611cbc565b608081019081106001600160401b03821117611cee57604052565b6001600160401b038111611cee57604052565b602081019081106001600160401b03821117611cee57604052565b90601f801991011681019081106001600160401b03821117611cee57604052565b60405190611d6a82611cd2565b565b60405190611d6a82611cf3565b6001600160401b038111611cee57601f01601f191660200190565b929192611da082611d79565b91611dae6040519384611d3c565b8294818452818301116102c4578281602093846000960137010152565b60603660031901126102c457600435611de3816102ff565b60243590611df0826102ff565b6001600160401b03916044358381116102c457366023820112156102c457611e22903690602481600401359101611d94565b60008051602061489c833981519152546001600160a01b039190611e499083163314612ccc565b611e538385612672565b90611e5d82612652565b61200a5760008281526000805160206148dc83398151915260209081526040822034600382015580546001600160a01b0319166001600160a01b0389161781559197600183810180546001600160a01b0319166001600160a01b038a1617905560068401928551928311611cee578a95611ee184611edb8754612462565b87612ef5565b81601f8511600114611f7e57509280806000805160206148bc8339815191529a999794899794600897611f4e9b94611f73575b50501b916000199060031b1c19161790555b0155611f3181612d40565b50611f4481611f3f87612a10565b612e57565b50611f3f86612a49565b50611f598385612c89565b60408051348152600060208201529382169490911692a380f35b015192503880611f14565b9190601f949394198416611f9787600052602060002090565b9389905b828210611ff0575050926008959285926000805160206148bc8339815191529c9b9996611f4e9b999610611fd7575b505050811b019055611f26565b015160001960f88460031b161c19169055388080611fca565b8385015186558f9a50948701949384019390810190611f9b565b604051632cf0675960e21b81526001600160a01b03868116600483015285166024820152604490fd5b346102c45760203660031901126102c457600435612050816102ff565b6120586121f7565b6001600160a01b03811615612070576113aa9061224f565b60405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b6064820152608490fd5b346102c45760203660031901126102c4576004356120e06121f7565b610e1081101580612107575b6120f590612296565b6000805160206148fc83398151915255005b5062093a808111156120ec565b9060206103359281815201906107b9565b346102c45761058a61214861213936610310565b90612142612371565b506125dd565b600a612152611d5d565b82546001600160a01b031681529160018101546001600160a01b0316602084015260028101546040840152600381015460608401526004810154608084015261219d600582016123dd565b60a08401526121ae6006820161249c565b60c08401526121cd6121c4600783015460ff1690565b151560e0850152565b60088101546101008401526009810154610120840152015461014082015260405191829182612114565b6000546001600160a01b0316330361220b57565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b600080546001600160a01b039283166001600160a01b03198216811783559216907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09080a3565b1561229d57565b60405162461bcd60e51b81526020600482015260156024820152746c6f636b54696d65206f7574206f662072616e676560581b6044820152606490fd5b90916122e59061224f565b610e1081101580612364575b6122fa90612296565b6000805160206148fc8339815191525560018060a01b03166bffffffffffffffffffffffff60a01b9060008051602061489c83398151915281838254161790557fdfd123095cdedb1cecbc229b30f7cf8745fb3d3951645ac4a8fa4c0895f8950291825416179055565b5062093a808111156122f1565b6040519061237e82611cd2565b81610140600091828152826020820152826040820152826060820152826080820152606060a0820152606060c08201528260e082015282610100820152826101208201520152565b6001600160401b038111611cee5760051b60200190565b9081546123e9816123c6565b926040936123f985519182611d3c565b828152809460208092019260005281600020906000935b85851061241f57505050505050565b600484600192845161243081611cf3565b86548152848701548382015260028701548682015260ff60038801541615156060820152815201930194019391612410565b90600182811c92168015612492575b602083101461247c57565b634e487b7160e01b600052602260045260246000fd5b91607f1691612471565b90604051918260008254926124b084612462565b90818452600194858116908160001461251d57506001146124da575b5050611d6a92500383611d3c565b9093915060005260209081600020936000915b818310612505575050611d6a935082010138806124cc565b855488840185015294850194879450918301916124ed565b915050611d6a94506020925060ff191682840152151560051b82010138806124cc565b90600a61254b611d5d565b83546001600160a01b031681529260018101546001600160a01b03166020850152600281015460408501526003810154606085015260048101546080850152612596600582016123dd565b60a08501526125a76006820161249c565b60c08501526125bd610fef600783015460ff1690565b600881015461010085015260098101546101208501520154610140830152565b906125e88183612672565b918260005260008051602061487c833981519152602052604060002054156126295750506000526000805160206148dc833981519152602052604060002090565b60405163023280eb60e21b81526001600160a01b03918216600482015291166024820152604490fd5b60005260008051602061487c833981519152602052604060002054151590565b604080516001600160a01b03928316602082019081529390921682820152815261269d606082611d3c565b51902090565b156126aa57565b60405162461bcd60e51b815260206004820152600f60248201526e4c696d697420746f6f206c6172676560881b6044820152606490fd5b6040516126ed81611d21565b6000815290565b906126fe826123c6565b61270b6040519182611d3c565b828152809261271c601f19916123c6565b019060005b82811061272d57505050565b602090612738612371565b82828501015201612721565b634e487b7160e01b600052601160045260246000fd5b9190820180921161276757565b612744565b60001981019190821161276757565b9190820391821161276757565b60001981146127675760010190565b634e487b7160e01b600052603260045260246000fd5b80518210156127c15760209160051b010190565b612797565b909160008051602061493c833981519152549182811015612867578381018082116127675793158385821561285d575b5050612854575b80840393841161276757612810846126f4565b9360005b81811061282057505050565b808301908184116127675761283a61195961284f93612877565b61284482896127ad565b5261192a81886127ad565b612814565b925081926127fd565b11905083386127f6565b509091506128736126e1565b9190565b60008051602061493c833981519152548110156127c1577fa543db6724dca3e06c9a739e16672b6894bb866e0b44759e50bc403282ce062701546000526000805160206148dc833981519152602052604060002090565b60008051602061491c833981519152548110156127c1577f94ce1cc9f419dbfb0d7a61a6415af9981ee3d1c02ba0de79a3c180abfae2b401015460005260008051602061497c833981519152602052604060002090565b60008051602061491c83398151915280548210156127c1576000527f94ce1cc9f419dbfb0d7a61a6415af9981ee3d1c02ba0de79a3c180abfae2b4010190600090565b60008051602061493c83398151915280548210156127c1576000527fa543db6724dca3e06c9a739e16672b6894bb866e0b44759e50bc403282ce06270190600090565b80548210156127c15760005260206000200190600090565b906129cd916129ab565b90549060031b1c90565b6001600160a01b031660009081527fdfd123095cdedb1cecbc229b30f7cf8745fb3d3951645ac4a8fa4c0895f8950b6020526040902090565b6001600160a01b031660009081527fdfd123095cdedb1cecbc229b30f7cf8745fb3d3951645ac4a8fa4c0895f895066020526040902090565b6001600160a01b031660009081527fdfd123095cdedb1cecbc229b30f7cf8745fb3d3951645ac4a8fa4c0895f895076020526040902090565b612a8e90939293612a10565b80549384831015612b3b5780612b2c5750835b82858211612b24575b612ab39161277b565b90612abd826126f4565b9260005b838110612ad057505050509190565b80612b0a611959612aed612ae7612b1f958761275a565b876129c3565b6000526000805160206148dc833981519152602052604060002090565b612b1482886127ad565b5261192a81876127ad565b612ac1565b859150612aaa565b820180831115612aa157612744565b505050604051612b4a81611d21565b600081529190565b612b5e90939293612a49565b80549384831015612b3b5780612bc45750835b82858211612bbc575b612b839161277b565b90612b8d826126f4565b9260005b838110612ba057505050509190565b80612b0a611959612aed612ae7612bb7958761275a565b612b91565b859150612b7a565b820180831115612b7157612744565b91908110156127c15760051b0190565b35610335816102ff565b612bf681612c54565b60005260008051602061497c83398151915260205260406000209060008051602061495c83398151915260205260406000205415612c32575090565b6040516304c76d3f60e11b81526001600160a01b039091166004820152602490fd5b604051602081019160018060a01b0316825260208152604081018181106001600160401b03821117611cee5760405251902090565b90612c93916125dd565b600781019081549060ff821680612cc4575b612cb6575b5060ff19166001179055565b600301546113ba5738612caa565b506000612ca5565b15612cd357565b60405162461bcd60e51b815260206004820152602160248201527f43616c6c6572206973206e6f7420746865206c656467657220636f6e747261636044820152601d60fa1b6064820152608490fd5b91612d3c9183549060031b91821b91600019901b19161790565b9055565b8060005260008051602061487c8339815191528060205260406000205415600014612dc85760008051602061493c8339815191528054600160401b811015611cee57600181018083558110156127c15783907fa543db6724dca3e06c9a739e16672b6894bb866e0b44759e50bc403282ce062701555491600052602052604060002055600190565b5050600090565b8060005260008051602061495c8339815191528060205260406000205415600014612dc85760008051602061491c8339815191528054600160401b811015611cee57600181018083558110156127c15783907f94ce1cc9f419dbfb0d7a61a6415af9981ee3d1c02ba0de79a3c180abfae2b40101555491600052602052604060002055600190565b6001810190826000528160205260406000205415600014612ec0578054600160401b811015611cee57612eab612e948260018794018555846129ab565b819391549060031b91821b91600019901b19161790565b90555491600052602052604060002055600190565b505050600090565b634e487b7160e01b600052600060045260246000fd5b818110612ee9575050565b60008155600101612ede565b9190601f8111612f0457505050565b611d6a926000526020600020906020601f840160051c83019310612f30575b601f0160051c0190612ede565b9091508190612f23565b91909182516001600160401b038111611cee57612f6181612f5b8454612462565b84612ef5565b602080601f8311600114612f9d575081929394600092612f92575b50508160011b916000199060031b1c1916179055565b015190503880612f7c565b90601f19831695612fb385600052602060002090565b926000905b888210612ff057505083600195969710612fd7575b505050811b019055565b015160001960f88460031b161c19169055388080612fcd565b80600185968294968601518155019501930190612fb8565b6130128154612462565b908161301c575050565b81601f6000931160011461302e575055565b90808391825261304d601f60208420940160051c840160018501612ede565b5555565b9061305c8183612672565b9161306683612652565b1561314f5761308083916130858361308061308b96612a10565b61339f565b50612a49565b50613095816132f2565b5060009081526000805160206148dc83398151915260205260408120818155816001820155816002820155816003820155600482818301556005820180549084815581613105575b505050806130ef6006600a9301613008565b8260078201558260088201558260098201550155565b6001600160fe1b0382168203612767578452602084209060021b8101905b818110156130dd5780613149849260036000918281558260018201558260028201550155565b01613123565b505050565b634e487b7160e01b600052603160045260246000fd5b60008051602061491c83398151915280549081156131bc57600019820191808310156127c1577f94ce1cc9f419dbfb0d7a61a6415af9981ee3d1c02ba0de79a3c180abfae2b400600091838352015555565b613154565b60008051602061493c83398151915280549081156131bc57600019820191808310156127c1577fa543db6724dca3e06c9a739e16672b6894bb866e0b44759e50bc403282ce0626600091838352015555565b80549081156131bc576000199182019161322d83836129ab565b909182549160031b1b1916905555565b600081815260008051602061495c83398151915260205260409020548015612dc85760001991818301918083116127675760008051602061491c833981519152549384019384116127675783836132bf94600096036132c5575b5050506132a261316a565b60005260008051602061495c833981519152602052604060002090565b55600190565b6132a26132e3916132db6129cd6132e995612925565b928391612925565b90612d22565b55388080613297565b600081815260008051602061487c83398151915260205260409020548015612dc85760001991818301918083116127675760008051602061493c833981519152549384019384116127675783836132bf9460009603613374575b5050506133576131c1565b60005260008051602061487c833981519152602052604060002090565b6133576132e39161338761339694612968565b90549060031b1c928391612968565b5538808061334c565b600181019180600052826020526040600020549283151560001461343f5760001992848401908582116127675780549485019485116127675760009585836133f3946132bf9803613402575b505050613213565b90600052602052604060002090565b6134266132e39161341661343694876129ab565b90549060031b1c928391876129ab565b8590600052602052604060002090565b553880806133eb565b50505050600090565b80548210156127c15760005260206000209060021b0190600090565b906134ab57818103613474575050565b600360ff8184611d6a95548555600181015460018601556002810154600286015501541691019060ff801983541691151516179055565b612ec8565b60050180545b8281116134c257505050565b815480156131bc57600019016134d88184613448565b6134ab57600360009182815582600182015582600282015501558255801561276757600019016134b6565b906134ab576003606083611d6a9451845560208101516001850155604081015160028501550151151591019060ff801983541691151516179055565b90815491600160401b831015611cee5782613562916001611d6a95018155613448565b90613503565b919061357481846125dd565b9260038401549161358b600486019384549061277b565b91821561365157600886019182549160058310156136285750506005612d3c949596019081548091106000146135fc57506135e99061356283546135cd611d6c565b9281845286602085015242604085015260006060850152613448565b6135f38154612788565b9055825461275a565b61362391613608611d6c565b9182528460208301524260408301526000606083015261353f565b6135e9565b604051639edd285f60e01b81526001600160a01b03918216600482015291166024820152604490fd5b505050509050565b3d15613684573d9061366a82611d79565b916136786040519384611d3c565b82523d6000602084013e565b606090565b90613693916125dd565b90600582019081541561381257600093600092600091825b825481101561376d576136be8184613448565b509760038901986136d08a5460ff1690565b613761576136e287600283015461275a565b4210613711576136fe61370c93926001610b6b9301549061275a565b8a5460ff1916600117909a55565b6136ab565b9661373a9199509461372c61370c939660018a01549061275a565b978187036137405750612788565b93612788565b61374e906112488388613448565b806137598187613448565b50553861192a565b50975061370c90612788565b50949250600883019180835581548082106137a2575b50505050816004600383019261379a87855461277b565b809455015591565b81906137b1600392839261277b565b106137ce57506137c190846134b0565b5490555b38808080613783565b96939592509390935b84548110156138065780610b6b886137f26138019489613448565b5001805460ff19166001179055565b6137d7565b509250929093506137c5565b50506003810154600490910154600092565b6040519061383182611cd2565b81610140600091828152606080602083015280604083015283818301528360808301528360a08301528060c08301528060e0830152610100820152826101208201520152565b90611d6a60ff6009613887611d5d565b85546001600160a01b03168152946138a16001820161249c565b60208701526138b26002820161249c565b60408701526003810154606087015260048101546080870152600581015460a08701526138e16006820161249c565b60c08701526138f26007820161249c565b60e08701526139036008820161249c565b61010087015201546001600160a01b03811661012086015260a01c161515610140840152565b90613933826123c6565b6139406040519182611d3c565b8281528092613951601f19916123c6565b019060005b82811061396257505050565b60209061396d613824565b82828501015201613956565b9160008051602061491c833981519152549182841015613a0657808401808511612767579015838282156139fc575b50506139f5575b838103908111612767576139c281613929565b9360005b8281106139d257505050565b8061283a6139eb6139e66139f0948661275a565b6128ce565b613877565b6139c6565b50816139af565b11905083386139a8565b50909150604051612b4a81611d21565b15613a1d57565b606460405162461bcd60e51b815260206004820152602060248201527f4d696e696d756d207374616b65206f66203130302030472072657175697265646044820152fd5b15613a6857565b60405162461bcd60e51b815260206004820152602b60248201527f43616e6e6f7420616464206d6f7265207374616b65207768656e20757064617460448201526a696e67207365727669636560a81b6064820152608490fd5b903590601e19813603018212156102c457018035906001600160401b0382116102c4576020019181360383136102c457565b908060209392818452848401376000828201840152601f01601f1916010190565b99979392613b649793613b39613b47936103359e9c98999560e08f8181520191613af3565b8c810360208e015291613af3565b9460408a01526060890152608088015286830360a0880152613af3565b9260c0818503910152613af3565b9092916001600160401b038111611cee57613b9181612f5b8454612462565b6000601f8211600114613bca5781929394600092613bbf5750508160011b916000199060031b1c1916179055565b013590503880612f7c565b601f19821694613bdf84600052602060002090565b91805b878110613c19575083600195969710613bff57505050811b019055565b0135600019600384901b60f8161c19169055388080612fcd565b90926020600181928686013581550194019101613be2565b60c0820190611000613c438385613ac1565b905011613f9d57613c5381612c54565b613c7a6111708260005260008051602061495c833981519152602052604060002054151590565b613ea35750613c8890612bed565b916001830191613c978361249c565b8051602080920120613cb3613cac8580613ac1565b3691611d94565b8281519101201493841594613e71575b8415613e3f575b8415613e0c575b858515613db2575b5083613d77613d6d600995613d2d613d23613d7d97613d0760e098613d0189613d9e9e613ac1565b91613b72565b608087013560038e015560a087013560048e0155860186613ac1565b9060028d01613b72565b4260058b0155613d4d613d436040860186613ac1565b9060068d01613b72565b613d67613d5d6060860186613ac1565b9060078d01613b72565b83613ac1565b9060088a01613b72565b01612be3565b930180546001600160a01b0319166001600160a01b03909416939093178355565b613da55750565b805460ff60a01b19169055565b60e091955093613d77613d6d600995613d2d613d23613d7d97613d07613ddd6008613d9e9d0161249c565b828151910120613df0613cac878b613ac1565b83815191012014159c9850509750505095505050935085613cd9565b60098601549094506001600160a01b0316613e2c610b0b60e08601612be3565b6001600160a01b03909116141593613cd1565b9350613e4d6007860161249c565b818151910120613e63613cac6060860186613ac1565b828151910120141593613cca565b9350613e7f6006860161249c565b818151910120613e95613cac6040860186613ac1565b828151910120141593613cc3565b929091613eb08280613ac1565b929091613ec06020830183613ac1565b92613ece6040820182613ac1565b9091613edd6060820182613ac1565b949095613eea9083613ac1565b97909860e08401613efa90612be3565b9a613f03611d5d565b6001600160a01b03909d168d523690613f1b92611d94565b60208c01523690613f2b92611d94565b60408a0152608081013560608a015260a0013560808901524260a08901523690613f5492611d94565b60c08701523690613f6492611d94565b60e08501523690613f7492611d94565b6101008301526001600160a01b03166101208201526000610140820152613f9a91613faf565b50565b60405163ef54fd9d60e01b8152600490fd5b6140c3610335928260005260008051602061497c8339815191526020526140a961014060096040600020614008613fec865160018060a01b031690565b82546001600160a01b0319166001600160a01b03909116178255565b614019602086015160018301612f3a565b61402a604086015160028301612f3a565b606085015160038201556080850151600482015560a0850151600582015561405960c086015160068301612f3a565b61406a60e086015160078301612f3a565b61407c61010086015160088301612f3a565b610120850151910180546001600160a01b0319166001600160a01b03909216919091178155920151151590565b815460ff60a01b191690151560a01b60ff60a01b16179055565b612dcf565b156140cf57565b60405162461bcd60e51b815260206004820152601360248201527214dd185ad9481c995d1d5c9b8819985a5b1959606a1b6044820152606490fd5b1561411157565b60405162461bcd60e51b815260206004820152601760248201527f4e6f20736574746c656d656e74732070726f76696465640000000000000000006044820152606490fd5b90614160826123c6565b61416d6040519182611d3c565b828152809261417e601f19916123c6565b0190602036910137565b91908110156127c15760051b8101359060be19813603018212156102c4570190565b156141b157565b60405162461bcd60e51b815260206004820152601d60248201527f546f6f206d616e7920736574746c656d656e747320696e2062617463680000006044820152606490fd5b6020909392919361420b8160408101966109d1565b0152565b6040513d6000823e3d90fd5b61422e61422782612be3565b33906125dd565b61423733612bed565b614248611170600784015460ff1690565b80156142ff575b80156142ea575b6142dd576002820154608084013511156142d0576009015461428590611170906001600160a01b03168461467e565b6142c4576003015460009160400135818111156142bc576142a6925061277b565b905b81156142b45760019190565b600091508190565b5050906142a8565b50906040600592013590565b5050906040600492013590565b5050906040600392013590565b5060098101546001600160a01b031615614256565b5060098101546143139060a01c60ff161590565b61424f565b61432461422782612be3565b9161432e33612bed565b61433f611170600786015460ff1690565b801561443b575b8015614426575b6144155760028401805491608085013580931015614402576009015461438090611170906001600160a01b03168661467e565b6143f05755604060038401549201359180831190816000146143ea5780935b600092156143e2576143b1925061277b565b925b82806143d2575b505082156143c9576001929190565b60009250829190565b6143db91614466565b38826143ba565b5050926143b3565b8361439f565b50509091506040600592013590600090565b5050509091506040600492013590600090565b509091506040600392013590600090565b5060098101546001600160a01b03161561434d565b50600981015461444f9060a01c60ff161590565b614346565b600160ff1b8114612767576000190190565b600391828201918254916004820192835490614482828261277b565b831161458f575b5050909192935061449b81855461277b565b84557fdfd123095cdedb1cecbc229b30f7cf8745fb3d3951645ac4a8fa4c0895f89502546144d1906001600160a01b0316610b0b565b82549091906001600160a01b031690823b156102c457604051631bb1482360e31b81526001600160a01b039290921660048301526024820152906000908290604490829084905af180156114c5576000805160206148bc833981519152926145719261454a92614576575b50546001600160a01b031690565b9354925460408051948552602085019190915233946001600160a01b031693918291820190565b0390a3565b8061458361458992611d0e565b806102c9565b3861453c565b6145a561459f836145ac9361277b565b8461277b565b809261277b565b845560058301906145bd825461276c565b600080821261465e576145d08285613448565b5090898201916145e1835460ff1690565b61465257600101805490949081811161463d575090614606614615939286549061277b565b9455805460ff19166001179055565b81156146295761462490614454565b6145bd565b50505090919293505b908392913880614489565b61464a929495935061277b565b905590614615565b50505061462490614454565b505050509091929350614632565b60ff601b9116019060ff821161276757565b60419061468e60a0820182613ac1565b92909203612ec057602091816146a78460009401612be3565b6146b082612be3565b604080516060808601358983019081526080870135602082015294811b6bffffffffffffffffffffffff199081168685015293901b90921660548401529290920135606882015281608882010391614710601f1993848101835282611d3c565b5190209061475f60405191826147538882019586603c917f19457468657265756d205369676e6564204d6573736167653a0a3332000000008252601c8201520190565b03908101835282611d3c565b519020906040810135831a90601b82106147be575b6040805193845260ff9092166020840152803591830191909152830135606082015280608081015b838052039060015afa156114c5576000516001600160a01b0390811691161490565b906147cb61479c9161466c565b919050614774565b906002936147e5846147f795946127ad565b6001600160a01b0390911690526127ad565b52565b926147e583614808956127ad565b60068210156109bb5752565b926147e5836147f7956127ad565b60405162461bcd60e51b815260206004820152602b60248201527f446972656374206465706f736974732064697361626c65643b20757365204c6560448201526a3233b2b926b0b730b3b2b960a91b6064820152608490fdfedfd123095cdedb1cecbc229b30f7cf8745fb3d3951645ac4a8fa4c0895f89504dfd123095cdedb1cecbc229b30f7cf8745fb3d3951645ac4a8fa4c0895f89501526824944047da5b81071fb6349412005c5da81380b336103fbe5dd34556c776dfd123095cdedb1cecbc229b30f7cf8745fb3d3951645ac4a8fa4c0895f89505dfd123095cdedb1cecbc229b30f7cf8745fb3d3951645ac4a8fa4c0895f89500dfd123095cdedb1cecbc229b30f7cf8745fb3d3951645ac4a8fa4c0895f89508dfd123095cdedb1cecbc229b30f7cf8745fb3d3951645ac4a8fa4c0895f89503dfd123095cdedb1cecbc229b30f7cf8745fb3d3951645ac4a8fa4c0895f89509dfd123095cdedb1cecbc229b30f7cf8745fb3d3951645ac4a8fa4c0895f8950aa2646970667358221220b823df78158f1f2bfcfff63c3d7117232a8b2f20c39460d72d0698cb5e0a22ad64736f6c63430008140033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
      },
      "supportsInterface(bytes4)": {
        "details": "See {IERC165-supportsInterface}."
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 7,
        "contract": "contracts/inference/InferenceServing.sol:InferenceServing",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 9981,
        "contract": "contracts/inference/InferenceServing.sol:InferenceServing",
        "label": "initialized",
        "offset": 20,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 123,
        "contract": "contracts/inference/InferenceServing.sol:InferenceServing",
        "label": "_status",
        "offset": 0,
        "slot": "1",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}