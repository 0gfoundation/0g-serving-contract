{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165Checker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.2) (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface.\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\n            !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\n        internal\n        view\n        returns (bool[] memory)\n    {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     *\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\n     * should be exercised when using this function.\n     *\n     * Interface identification is specified in ERC-165.\n     */\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\n        // prepare call\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\n\n        // perform static call\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly {\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableMap.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\n\npragma solidity ^0.8.0;\n\nimport \"./EnumerableSet.sol\";\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * The following map types are supported:\n *\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableMap.\n * ====\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct Bytes32ToBytes32Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 => bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        Bytes32ToBytes32Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) internal returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || contains(map, key), \"EnumerableMap: nonexistent key\");\n        return value;\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        Bytes32ToBytes32Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || contains(map, key), errorMessage);\n        return value;\n    }\n\n    // UintToUintMap\n\n    struct UintToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToUintMap storage map,\n        uint256 key,\n        uint256 value\n    ) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(key)));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToUintMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(key), errorMessage));\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToAddressMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key), errorMessage))));\n    }\n\n    // AddressToUintMap\n\n    struct AddressToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        AddressToUintMap storage map,\n        address key,\n        uint256 value\n    ) internal returns (bool) {\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\n        return remove(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\n        return contains(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (address(uint160(uint256(key))), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        AddressToUintMap storage map,\n        address key,\n        string memory errorMessage\n    ) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key))), errorMessage));\n    }\n\n    // Bytes32ToUintMap\n\n    struct Bytes32ToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        Bytes32ToUintMap storage map,\n        bytes32 key,\n        uint256 value\n    ) internal returns (bool) {\n        return set(map._inner, key, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\n        return remove(map._inner, key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\n        return contains(map._inner, key);\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (key, uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, key);\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\n        return uint256(get(map._inner, key));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        Bytes32ToUintMap storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) internal view returns (uint256) {\n        return uint256(get(map._inner, key, errorMessage));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/fine-tuning/FineTuningAccount.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n// Constants\nuint constant MAX_DELIVERABLES_PER_ACCOUNT = 20;\n\nstruct Account {\n    address user;\n    address provider;\n    uint nonce;\n    uint balance;\n    uint pendingRefund;\n    Refund[] refunds;\n    string additionalInfo;\n    address providerSigner;\n    mapping(string => Deliverable) deliverables; // ID -> Deliverable mapping\n    string[MAX_DELIVERABLES_PER_ACCOUNT] deliverableIds; // Circular array of IDs\n    uint validRefundsLength; // Track the number of valid (non-dirty) refunds\n    uint deliverablesHead; // Circular array head pointer (oldest position)\n    uint deliverablesCount; // Current count of deliverables\n}\n\nstruct Refund {\n    uint index;\n    uint amount;\n    uint createdAt;\n    bool processed;\n}\n\nstruct Deliverable {\n    string id; // Unique identifier for the deliverable\n    bytes modelRootHash;\n    bytes encryptedSecret;\n    bool acknowledged;\n    uint timestamp; // When this deliverable was added\n}\n\nstruct AccountSummary {\n    address user;\n    address provider;\n    uint nonce;\n    uint balance;\n    uint pendingRefund;\n    string additionalInfo;\n    address providerSigner;\n    uint validRefundsLength;\n    uint deliverablesCount;\n}\n\nstruct AccountDetails {\n    address user;\n    address provider;\n    uint nonce;\n    uint balance;\n    uint pendingRefund;\n    Refund[] refunds;\n    string additionalInfo;\n    address providerSigner;\n    Deliverable[] deliverables; // For backward compatibility, we'll populate this from the mapping\n    uint validRefundsLength;\n    uint deliverablesHead;\n    uint deliverablesCount;\n}\n\nlibrary AccountLibrary {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // Constants for optimization\n    uint constant MAX_REFUNDS_PER_ACCOUNT = 30;\n    uint constant REFUND_CLEANUP_THRESHOLD = 15;\n\n    error AccountNotExists(address user, address provider);\n    error AccountExists(address user, address provider);\n    error InsufficientBalance(address user, address provider);\n    error RefundInvalid(address user, address provider, uint index);\n    error RefundProcessed(address user, address provider, uint index);\n    error RefundLocked(address user, address provider, uint index);\n    error TooManyRefunds(address user, address provider);\n\n    struct AccountMap {\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 => Account) _values;\n        mapping(address => EnumerableSet.Bytes32Set) _providerIndex;\n        mapping(address => EnumerableSet.Bytes32Set) _userIndex;\n    }\n\n    // user functions\n\n    function getAccount(\n        AccountMap storage map,\n        address user,\n        address provider\n    ) internal view returns (Account storage) {\n        return _get(map, user, provider);\n    }\n\n    // Get account details for external interfaces (converts mapping to array)\n    function getAccountDetails(\n        AccountMap storage map,\n        address user,\n        address provider\n    ) internal view returns (AccountDetails memory details) {\n        Account storage account = _get(map, user, provider);\n\n        // Get deliverables in chronological order\n        Deliverable[] memory deliverables = getDeliverables(map, user, provider);\n\n        details = AccountDetails({\n            user: account.user,\n            provider: account.provider,\n            nonce: account.nonce,\n            balance: account.balance,\n            pendingRefund: account.pendingRefund,\n            refunds: account.refunds,\n            additionalInfo: account.additionalInfo,\n            providerSigner: account.providerSigner,\n            deliverables: deliverables,\n            validRefundsLength: account.validRefundsLength,\n            deliverablesHead: account.deliverablesHead,\n            deliverablesCount: account.deliverablesCount\n        });\n    }\n\n    function getAllAccounts(\n        AccountMap storage map,\n        uint offset,\n        uint limit\n    ) internal view returns (AccountSummary[] memory accounts, uint total) {\n        total = _length(map);\n\n        if (offset >= total) {\n            return (new AccountSummary[](0), total);\n        }\n\n        uint end = offset + limit;\n        if (limit == 0 || end > total) {\n            end = total;\n        }\n\n        uint resultLength = end - offset;\n        accounts = new AccountSummary[](resultLength);\n\n        for (uint i = 0; i < resultLength; i++) {\n            Account storage fullAccount = _at(map, offset + i);\n            accounts[i] = AccountSummary({\n                user: fullAccount.user,\n                provider: fullAccount.provider,\n                nonce: fullAccount.nonce,\n                balance: fullAccount.balance,\n                pendingRefund: fullAccount.pendingRefund,\n                additionalInfo: fullAccount.additionalInfo,\n                providerSigner: fullAccount.providerSigner,\n                validRefundsLength: fullAccount.validRefundsLength,\n                deliverablesCount: fullAccount.deliverablesCount\n            });\n        }\n    }\n\n    function getAccountsByProvider(\n        AccountMap storage map,\n        address provider,\n        uint offset,\n        uint limit\n    ) internal view returns (AccountSummary[] memory accounts, uint total) {\n        EnumerableSet.Bytes32Set storage providerKeys = map._providerIndex[provider];\n        total = providerKeys.length();\n\n        if (offset >= total) {\n            return (new AccountSummary[](0), total);\n        }\n\n        uint end = limit == 0 ? total : offset + limit;\n        if (end > total) {\n            end = total;\n        }\n\n        uint resultLen = end - offset;\n        accounts = new AccountSummary[](resultLen);\n\n        for (uint i = 0; i < resultLen; i++) {\n            bytes32 key = providerKeys.at(offset + i);\n            Account storage fullAccount = map._values[key];\n            accounts[i] = AccountSummary({\n                user: fullAccount.user,\n                provider: fullAccount.provider,\n                nonce: fullAccount.nonce,\n                balance: fullAccount.balance,\n                pendingRefund: fullAccount.pendingRefund,\n                additionalInfo: fullAccount.additionalInfo,\n                providerSigner: fullAccount.providerSigner,\n                validRefundsLength: fullAccount.validRefundsLength,\n                deliverablesCount: fullAccount.deliverablesCount\n            });\n        }\n\n        return (accounts, total);\n    }\n\n    function getAccountsByUser(\n        AccountMap storage map,\n        address user,\n        uint offset,\n        uint limit\n    ) internal view returns (AccountSummary[] memory accounts, uint total) {\n        EnumerableSet.Bytes32Set storage userKeys = map._userIndex[user];\n        total = userKeys.length();\n\n        if (offset >= total) {\n            return (new AccountSummary[](0), total);\n        }\n\n        uint end = limit == 0 ? total : offset + limit;\n        if (end > total) {\n            end = total;\n        }\n\n        uint resultLen = end - offset;\n        accounts = new AccountSummary[](resultLen);\n\n        for (uint i = 0; i < resultLen; i++) {\n            bytes32 key = userKeys.at(offset + i);\n            Account storage fullAccount = map._values[key];\n            accounts[i] = AccountSummary({\n                user: fullAccount.user,\n                provider: fullAccount.provider,\n                nonce: fullAccount.nonce,\n                balance: fullAccount.balance,\n                pendingRefund: fullAccount.pendingRefund,\n                additionalInfo: fullAccount.additionalInfo,\n                providerSigner: fullAccount.providerSigner,\n                validRefundsLength: fullAccount.validRefundsLength,\n                deliverablesCount: fullAccount.deliverablesCount\n            });\n        }\n\n        return (accounts, total);\n    }\n\n    function getBatchAccountsByUsers(\n        AccountMap storage map,\n        address[] calldata users,\n        address provider\n    ) internal view returns (AccountSummary[] memory accounts) {\n        require(users.length <= 500, \"Batch size too large (max 500)\");\n        accounts = new AccountSummary[](users.length);\n\n        for (uint i = 0; i < users.length; i++) {\n            bytes32 key = _key(users[i], provider);\n            if (_contains(map, key)) {\n                Account storage fullAccount = map._values[key];\n                accounts[i] = AccountSummary({\n                    user: fullAccount.user,\n                    provider: fullAccount.provider,\n                    nonce: fullAccount.nonce,\n                    balance: fullAccount.balance,\n                    pendingRefund: fullAccount.pendingRefund,\n                    additionalInfo: fullAccount.additionalInfo,\n                    providerSigner: fullAccount.providerSigner,\n                    validRefundsLength: fullAccount.validRefundsLength,\n                    deliverablesCount: fullAccount.deliverablesCount\n                });\n            }\n        }\n    }\n\n    function accountExists(AccountMap storage map, address user, address provider) internal view returns (bool) {\n        return _contains(map, _key(user, provider));\n    }\n\n    function getPendingRefund(AccountMap storage map, address user, address provider) internal view returns (uint) {\n        Account storage account = _get(map, user, provider);\n        return account.pendingRefund;\n    }\n\n    function addAccount(\n        AccountMap storage map,\n        address user,\n        address provider,\n        uint amount,\n        string memory additionalInfo\n    ) internal returns (uint, uint) {\n        bytes32 key = _key(user, provider);\n        if (_contains(map, key)) {\n            revert AccountExists(user, provider);\n        }\n\n        _set(map, key, user, provider, amount, additionalInfo);\n\n        map._providerIndex[provider].add(key);\n        map._userIndex[user].add(key);\n\n        return (amount, 0);\n    }\n\n    function deleteAccount(AccountMap storage map, address user, address provider) internal {\n        bytes32 key = _key(user, provider);\n        if (!_contains(map, key)) {\n            return;\n        }\n\n        map._providerIndex[provider].remove(key);\n        map._userIndex[user].remove(key);\n        map._keys.remove(key);\n        delete map._values[key];\n    }\n\n    function depositFund(\n        AccountMap storage map,\n        address user,\n        address provider,\n        uint cancelRetrievingAmount,\n        uint amount\n    ) internal returns (uint, uint) {\n        Account storage account = _get(map, user, provider);\n\n        if (cancelRetrievingAmount > 0 && account.refunds.length > 0) {\n            uint remainingCancel = cancelRetrievingAmount;\n            uint newPendingRefund = account.pendingRefund;\n\n            // Process refunds in-place to avoid memory allocation\n            uint writeIndex = 0;\n            for (uint i = 0; i < account.refunds.length; i++) {\n                Refund storage refund = account.refunds[i];\n\n                if (refund.processed) {\n                    continue;\n                }\n\n                if (remainingCancel >= refund.amount) {\n                    remainingCancel -= refund.amount;\n                    newPendingRefund -= refund.amount;\n                    refund.processed = true; // Mark as processed instead of removing\n                } else if (remainingCancel > 0) {\n                    refund.amount -= remainingCancel;\n                    newPendingRefund -= remainingCancel;\n                    remainingCancel = 0;\n                }\n\n                // Keep unprocessed refunds\n                if (!refund.processed && i != writeIndex) {\n                    account.refunds[writeIndex] = refund;\n                    account.refunds[writeIndex].index = writeIndex;\n                    writeIndex++;\n                } else if (!refund.processed) {\n                    writeIndex++;\n                }\n            }\n\n            // Update validRefundsLength after cancelling refunds\n            account.validRefundsLength = writeIndex;\n\n            // Cleanup if needed\n            if (writeIndex < account.refunds.length) {\n                _cleanupRefunds(account, writeIndex);\n            }\n\n            account.pendingRefund = newPendingRefund;\n        }\n\n        account.balance += amount;\n        return (account.balance, account.pendingRefund);\n    }\n\n    function requestRefund(\n        AccountMap storage map,\n        address user,\n        address provider,\n        uint amount\n    ) internal returns (uint) {\n        Account storage account = _get(map, user, provider);\n        if ((account.balance - account.pendingRefund) < amount) {\n            revert InsufficientBalance(user, provider);\n        }\n\n        // Check refund limit using validRefundsLength\n        if (account.validRefundsLength >= MAX_REFUNDS_PER_ACCOUNT) {\n            revert TooManyRefunds(user, provider);\n        }\n\n        uint newIndex;\n        if (account.validRefundsLength < account.refunds.length) {\n            // Reuse dirty position (saves ~15,000 gas)\n            newIndex = account.validRefundsLength;\n            account.refunds[newIndex] = Refund(newIndex, amount, block.timestamp, false);\n        } else {\n            // Need to push new position\n            newIndex = account.refunds.length;\n            account.refunds.push(Refund(newIndex, amount, block.timestamp, false));\n        }\n\n        account.validRefundsLength++;\n        account.pendingRefund += amount;\n        return newIndex;\n    }\n\n    function requestRefundAll(AccountMap storage map, address user, address provider) internal {\n        Account storage account = _get(map, user, provider);\n        uint amount = account.balance - account.pendingRefund;\n        if (amount == 0) {\n            return;\n        }\n\n        // Check refund limit using validRefundsLength\n        if (account.validRefundsLength >= MAX_REFUNDS_PER_ACCOUNT) {\n            revert TooManyRefunds(user, provider);\n        }\n\n        uint newIndex;\n        if (account.validRefundsLength < account.refunds.length) {\n            // Reuse dirty position (saves ~15,000 gas)\n            newIndex = account.validRefundsLength;\n            account.refunds[newIndex] = Refund(newIndex, amount, block.timestamp, false);\n        } else {\n            // Need to push new position\n            newIndex = account.refunds.length;\n            account.refunds.push(Refund(newIndex, amount, block.timestamp, false));\n        }\n\n        account.validRefundsLength++;\n        account.pendingRefund += amount;\n    }\n\n    function processRefund(\n        AccountMap storage map,\n        address user,\n        address provider,\n        uint lockTime\n    ) internal returns (uint totalAmount, uint balance, uint pendingRefund) {\n        Account storage account = _get(map, user, provider);\n\n        if (account.refunds.length == 0) {\n            return (0, account.balance, account.pendingRefund);\n        }\n\n        totalAmount = 0;\n        pendingRefund = 0;\n        uint writeIndex = 0;\n        uint currentTime = block.timestamp;\n\n        // Process refunds in-place\n        for (uint i = 0; i < account.refunds.length; i++) {\n            Refund storage refund = account.refunds[i];\n\n            if (refund.processed) {\n                continue;\n            }\n\n            if (currentTime >= refund.createdAt + lockTime) {\n                totalAmount += refund.amount;\n                refund.processed = true; // Mark as processed\n            } else {\n                pendingRefund += refund.amount;\n                // Keep unprocessed refunds\n                if (i != writeIndex) {\n                    account.refunds[writeIndex] = refund;\n                    account.refunds[writeIndex].index = writeIndex;\n                }\n                writeIndex++;\n            }\n        }\n\n        // Update valid refunds length\n        account.validRefundsLength = writeIndex;\n\n        // Clean up or mark dirty data\n        if (writeIndex < account.refunds.length) {\n            uint dirtyCount = account.refunds.length - writeIndex;\n\n            if (dirtyCount >= REFUND_CLEANUP_THRESHOLD) {\n                // Many dirty entries: physical cleanup is more efficient\n                _cleanupRefunds(account, writeIndex);\n            } else {\n                // Few dirty entries: mark as processed to prevent duplicate processing\n                for (uint i = writeIndex; i < account.refunds.length; i++) {\n                    account.refunds[i].processed = true;\n                }\n            }\n        }\n\n        account.balance -= totalAmount;\n        account.pendingRefund = pendingRefund;\n        balance = account.balance;\n    }\n\n    function acknowledgeProviderSigner(\n        AccountMap storage map,\n        address user,\n        address provider,\n        address providerSigner\n    ) internal {\n        if (!_contains(map, _key(user, provider))) {\n            revert AccountNotExists(user, provider);\n        }\n        Account storage account = _get(map, user, provider);\n        account.providerSigner = providerSigner;\n    }\n\n    function acknowledgeDeliverable(\n        AccountMap storage map,\n        address user,\n        address provider,\n        string calldata id\n    ) internal {\n        if (!_contains(map, _key(user, provider))) {\n            revert AccountNotExists(user, provider);\n        }\n        Account storage account = _get(map, user, provider);\n\n        // Check if deliverable exists\n        if (bytes(account.deliverables[id].id).length == 0) {\n            revert(\"Deliverable does not exist\");\n        }\n\n        // Mark as acknowledged\n        account.deliverables[id].acknowledged = true;\n    }\n\n    // provider functions\n\n    function addDeliverable(\n        AccountMap storage map,\n        address user,\n        address provider,\n        string calldata id,\n        bytes memory modelRootHash\n    ) internal {\n        if (!_contains(map, _key(user, provider))) {\n            revert AccountNotExists(user, provider);\n        }\n        Account storage account = _get(map, user, provider);\n\n        // Check if ID already exists\n        if (bytes(account.deliverables[id].id).length != 0) {\n            revert(\"Deliverable ID already exists\");\n        }\n\n        // Create new deliverable\n        Deliverable memory deliverable = Deliverable({\n            id: id,\n            modelRootHash: modelRootHash,\n            encryptedSecret: \"\",\n            acknowledged: false,\n            timestamp: block.timestamp\n        });\n\n        if (account.deliverablesCount < MAX_DELIVERABLES_PER_ACCOUNT) {\n            // Array not full, add to next available position\n            account.deliverableIds[account.deliverablesCount] = id;\n            account.deliverablesCount++;\n        } else {\n            // Array is full, remove oldest and add new one\n            string memory oldestId = account.deliverableIds[account.deliverablesHead];\n            delete account.deliverables[oldestId]; // Remove from mapping\n\n            account.deliverableIds[account.deliverablesHead] = id; // Overwrite with new ID\n            account.deliverablesHead = (account.deliverablesHead + 1) % MAX_DELIVERABLES_PER_ACCOUNT;\n        }\n\n        // Add to mapping\n        account.deliverables[id] = deliverable;\n    }\n\n    // Get deliverable by ID\n    function getDeliverable(\n        AccountMap storage map,\n        address user,\n        address provider,\n        string calldata id\n    ) internal view returns (Deliverable memory) {\n        Account storage account = _get(map, user, provider);\n        if (bytes(account.deliverables[id].id).length == 0) {\n            revert(\"Deliverable does not exist\");\n        }\n        return account.deliverables[id];\n    }\n\n    // Get all deliverable IDs in chronological order (oldest to newest)\n    function getDeliverableIds(\n        AccountMap storage map,\n        address user,\n        address provider\n    ) internal view returns (string[] memory ids) {\n        Account storage account = _get(map, user, provider);\n        uint count = account.deliverablesCount;\n\n        if (count == 0) {\n            return new string[](0);\n        }\n\n        ids = new string[](count);\n\n        if (count < MAX_DELIVERABLES_PER_ACCOUNT) {\n            // Array not full yet, deliverables are in chronological order from index 0\n            for (uint i = 0; i < count; i++) {\n                ids[i] = account.deliverableIds[i];\n            }\n        } else {\n            // Array is full, need to reorder starting from the oldest (at head position)\n            uint head = account.deliverablesHead;\n            for (uint i = 0; i < count; i++) {\n                uint sourceIndex = (head + i) % MAX_DELIVERABLES_PER_ACCOUNT;\n                ids[i] = account.deliverableIds[sourceIndex];\n            }\n        }\n\n        return ids;\n    }\n\n    // Get all deliverables in chronological order\n    function getDeliverables(\n        AccountMap storage map,\n        address user,\n        address provider\n    ) internal view returns (Deliverable[] memory deliverables) {\n        string[] memory ids = getDeliverableIds(map, user, provider);\n        deliverables = new Deliverable[](ids.length);\n\n        Account storage account = _get(map, user, provider);\n        for (uint i = 0; i < ids.length; i++) {\n            deliverables[i] = account.deliverables[ids[i]];\n        }\n\n        return deliverables;\n    }\n\n    // Helper functions\n\n    function _cleanupRefunds(Account storage account, uint keepCount) private {\n        // Resize array to remove processed refunds\n        uint currentLength = account.refunds.length;\n        for (uint i = currentLength; i > keepCount; i--) {\n            account.refunds.pop();\n        }\n    }\n\n    // common functions\n\n    function _at(AccountMap storage map, uint index) internal view returns (Account storage) {\n        bytes32 key = map._keys.at(index);\n        return map._values[key];\n    }\n\n    function _contains(AccountMap storage map, bytes32 key) internal view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    function _length(AccountMap storage map) internal view returns (uint) {\n        return map._keys.length();\n    }\n\n    function _get(AccountMap storage map, address user, address provider) internal view returns (Account storage) {\n        bytes32 key = _key(user, provider);\n        Account storage value = map._values[key];\n        if (!_contains(map, key)) {\n            revert AccountNotExists(user, provider);\n        }\n        return value;\n    }\n\n    function _set(\n        AccountMap storage map,\n        bytes32 key,\n        address user,\n        address provider,\n        uint balance,\n        string memory additionalInfo\n    ) internal {\n        Account storage account = map._values[key];\n        account.balance = balance;\n        account.user = user;\n        account.provider = provider;\n        account.additionalInfo = additionalInfo;\n        account.validRefundsLength = 0; // Initialize validRefundsLength\n        account.deliverablesHead = 0; // Initialize circular array head\n        account.deliverablesCount = 0; // Initialize deliverable count\n        map._keys.add(key);\n    }\n\n    function _key(address user, address provider) internal pure returns (bytes32) {\n        return keccak256(abi.encode(user, provider));\n    }\n}\n"
    },
    "contracts/fine-tuning/FineTuningService.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nstruct Service {\n    address provider;\n    string url;\n    Quota quota;\n    uint pricePerToken;\n    address providerSigner;\n    bool occupied;\n    string[] models;\n}\n\nstruct Quota {\n    uint cpuCount;\n    uint nodeMemory;\n    uint gpuCount;\n    uint nodeStorage;\n    string gpuType;\n}\n\nlibrary ServiceLibrary {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    error ServiceNotExist(address provider);\n\n    struct ServiceMap {\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 => Service) _values;\n    }\n\n    function getService(ServiceMap storage map, address provider) internal view returns (Service storage) {\n        return _get(map, provider);\n    }\n\n    function getAllServices(ServiceMap storage map) internal view returns (Service[] memory services) {\n        uint len = _length(map);\n        services = new Service[](len);\n        for (uint i = 0; i < len; ++i) {\n            services[i] = _at(map, i);\n        }\n    }\n\n    function addOrUpdateService(\n        ServiceMap storage map,\n        address provider,\n        string memory url,\n        Quota memory quota,\n        uint pricePerToken,\n        address providerSigner,\n        bool occupied,\n        string[] memory models\n    ) internal {\n        bytes32 key = _key(provider);\n        if (!_contains(map, key)) {\n            _set(map, key, Service(provider, url, quota, pricePerToken, providerSigner, false, models));\n            return;\n        }\n        Service storage value = _get(map, provider);\n        value.url = url;\n        value.quota = quota;\n        value.pricePerToken = pricePerToken;\n        value.providerSigner = providerSigner;\n        value.occupied = occupied;\n        value.models = models;\n    }\n\n    function removeService(ServiceMap storage map, address provider) internal {\n        bytes32 key = _key(provider);\n        if (!_contains(map, key)) {\n            revert ServiceNotExist(provider);\n        }\n        _remove(map, key);\n    }\n\n    function _at(ServiceMap storage map, uint index) internal view returns (Service storage) {\n        bytes32 key = map._keys.at(index);\n        return map._values[key];\n    }\n\n    function _set(ServiceMap storage map, bytes32 key, Service memory value) internal returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    function _get(ServiceMap storage map, address provider) internal view returns (Service storage) {\n        bytes32 key = _key(provider);\n        Service storage value = map._values[key];\n        if (!_contains(map, key)) {\n            revert ServiceNotExist(provider);\n        }\n        return value;\n    }\n\n    function _remove(ServiceMap storage map, bytes32 key) internal returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    function _contains(ServiceMap storage map, bytes32 key) internal view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    function _length(ServiceMap storage map) internal view returns (uint) {\n        return map._keys.length();\n    }\n\n    function _key(address provider) internal pure returns (bytes32) {\n        return keccak256(abi.encode(provider));\n    }\n}\n"
    },
    "contracts/fine-tuning/FineTuningServing.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"../utils/Initializable.sol\";\nimport \"./FineTuningAccount.sol\";\nimport \"../ledger/LedgerManager.sol\";\n\nusing AccountLibrary for AccountLibrary.AccountMap;\nimport \"./FineTuningService.sol\";\nimport \"./FineTuningVerifier.sol\";\n\ninterface ISignatureVerifier {\n    function verifySignature(\n        string memory message,\n        bytes memory signature,\n        address expectedAddress\n    ) external view returns (bool);\n}\n\ncontract FineTuningServing is Ownable, Initializable, ReentrancyGuard, IServing, ERC165 {\n    using AccountLibrary for AccountLibrary.AccountMap;\n    using ServiceLibrary for ServiceLibrary.ServiceMap;\n    using VerifierLibrary for VerifierInput;\n\n    // @custom:storage-location erc7201:0g.serving.finetuning.v1.0\n    struct FineTuningServingStorage {\n        uint lockTime;\n        address ledgerAddress;\n        ILedger ledger;\n        AccountLibrary.AccountMap accountMap;\n        ServiceLibrary.ServiceMap serviceMap;\n        uint penaltyPercentage;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"0g.serving.finetuning.v1.0\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant FINETUNING_SERVING_STORAGE_LOCATION = 0x5dcaaa00d1d3fae8cd5d66aceca789aec54970049ac35cb62a7adefca50a6800;\n\n    function _getFineTuningServingStorage() private pure returns (FineTuningServingStorage storage $) {\n        assembly {\n            $.slot := FINETUNING_SERVING_STORAGE_LOCATION\n        }\n    }\n\n    // Public getters for compatibility\n    function lockTime() public view returns (uint) {\n        FineTuningServingStorage storage $ = _getFineTuningServingStorage();\n        return $.lockTime;\n    }\n\n    function ledgerAddress() public view returns (address) {\n        FineTuningServingStorage storage $ = _getFineTuningServingStorage();\n        return $.ledgerAddress;\n    }\n\n    function penaltyPercentage() public view returns (uint) {\n        FineTuningServingStorage storage $ = _getFineTuningServingStorage();\n        return $.penaltyPercentage;\n    }\n\n    event BalanceUpdated(address indexed user, address indexed provider, uint amount, uint pendingRefund);\n    event RefundRequested(address indexed user, address indexed provider, uint indexed index, uint timestamp);\n    event ServiceUpdated(\n        address indexed user,\n        string url,\n        Quota quota,\n        uint pricePerToken,\n        address providerSigner,\n        bool occupied\n    );\n    event ServiceRemoved(address indexed user);\n    error InvalidVerifierInput(string reason);\n\n    function initialize(\n        uint _locktime,\n        address _ledgerAddress,\n        address owner,\n        uint _penaltyPercentage\n    ) public onlyInitializeOnce {\n        FineTuningServingStorage storage $ = _getFineTuningServingStorage();\n        _transferOwnership(owner);\n        $.lockTime = _locktime;\n        $.ledgerAddress = _ledgerAddress;\n        $.ledger = ILedger(_ledgerAddress);\n        $.penaltyPercentage = _penaltyPercentage;\n    }\n\n    modifier onlyLedger() {\n        FineTuningServingStorage storage $ = _getFineTuningServingStorage();\n        require(msg.sender == $.ledgerAddress, \"Caller is not the ledger contract\");\n        _;\n    }\n\n    function updateLockTime(uint _locktime) public onlyOwner {\n        FineTuningServingStorage storage $ = _getFineTuningServingStorage();\n        $.lockTime = _locktime;\n    }\n\n    function updatePenaltyPercentage(uint _penaltyPercentage) public onlyOwner {\n        FineTuningServingStorage storage $ = _getFineTuningServingStorage();\n        $.penaltyPercentage = _penaltyPercentage;\n    }\n\n    // user functions\n\n    function getAccount(address user, address provider) public view returns (AccountDetails memory) {\n        FineTuningServingStorage storage $ = _getFineTuningServingStorage();\n        return $.accountMap.getAccountDetails(user, provider);\n    }\n\n    function getAllAccounts(\n        uint offset,\n        uint limit\n    ) public view returns (AccountSummary[] memory accounts, uint total) {\n        FineTuningServingStorage storage $ = _getFineTuningServingStorage();\n        require(limit == 0 || limit <= 50, \"Limit too large\");\n        return $.accountMap.getAllAccounts(offset, limit);\n    }\n\n    function getAccountsByProvider(\n        address provider,\n        uint offset,\n        uint limit\n    ) public view returns (AccountSummary[] memory accounts, uint total) {\n        FineTuningServingStorage storage $ = _getFineTuningServingStorage();\n        require(limit == 0 || limit <= 50, \"Limit too large\");\n        return $.accountMap.getAccountsByProvider(provider, offset, limit);\n    }\n\n    function getAccountsByUser(\n        address user,\n        uint offset,\n        uint limit\n    ) public view returns (AccountSummary[] memory accounts, uint total) {\n        FineTuningServingStorage storage $ = _getFineTuningServingStorage();\n        require(limit == 0 || limit <= 50, \"Limit too large\");\n        return $.accountMap.getAccountsByUser(user, offset, limit);\n    }\n\n    function getBatchAccountsByUsers(\n        address[] calldata users\n    ) external view returns (AccountSummary[] memory accounts) {\n        FineTuningServingStorage storage $ = _getFineTuningServingStorage();\n        return $.accountMap.getBatchAccountsByUsers(users, msg.sender);\n    }\n\n    function accountExists(address user, address provider) public view returns (bool) {\n        FineTuningServingStorage storage $ = _getFineTuningServingStorage();\n        return $.accountMap.accountExists(user, provider);\n    }\n\n    function getPendingRefund(address user, address provider) public view returns (uint) {\n        FineTuningServingStorage storage $ = _getFineTuningServingStorage();\n        return $.accountMap.getPendingRefund(user, provider);\n    }\n\n    function addAccount(address user, address provider, string memory additionalInfo) external payable onlyLedger {\n        FineTuningServingStorage storage $ = _getFineTuningServingStorage();\n        (uint balance, uint pendingRefund) = $.accountMap.addAccount(user, provider, msg.value, additionalInfo);\n        emit BalanceUpdated(user, provider, balance, pendingRefund);\n    }\n\n    function deleteAccount(address user, address provider) external onlyLedger {\n        FineTuningServingStorage storage $ = _getFineTuningServingStorage();\n        $.accountMap.deleteAccount(user, provider);\n    }\n\n    function depositFund(address user, address provider, uint cancelRetrievingAmount) external payable onlyLedger {\n        FineTuningServingStorage storage $ = _getFineTuningServingStorage();\n        (uint balance, uint pendingRefund) = $.accountMap.depositFund(user, provider, cancelRetrievingAmount, msg.value);\n        emit BalanceUpdated(user, provider, balance, pendingRefund);\n    }\n\n    function requestRefundAll(address user, address provider) external onlyLedger {\n        FineTuningServingStorage storage $ = _getFineTuningServingStorage();\n        $.accountMap.requestRefundAll(user, provider);\n    }\n\n    function processRefund(\n        address user,\n        address provider\n    ) external onlyLedger returns (uint totalAmount, uint balance, uint pendingRefund) {\n        FineTuningServingStorage storage $ = _getFineTuningServingStorage();\n        (totalAmount, balance, pendingRefund) = $.accountMap.processRefund(user, provider, $.lockTime);\n        if (totalAmount == 0) {\n            return (0, balance, pendingRefund);\n        }\n        (bool success, ) = payable(msg.sender).call{value: totalAmount}(\"\");\n        require(success, \"transfer to ledger failed\");\n        emit BalanceUpdated(user, provider, balance, pendingRefund);\n    }\n\n    function getService(address provider) public view returns (Service memory service) {\n        FineTuningServingStorage storage $ = _getFineTuningServingStorage();\n        service = $.serviceMap.getService(provider);\n    }\n\n    function getAllServices() public view returns (Service[] memory services) {\n        FineTuningServingStorage storage $ = _getFineTuningServingStorage();\n        services = $.serviceMap.getAllServices();\n    }\n\n    function acknowledgeProviderSigner(address provider, address providerSigner) external {\n        FineTuningServingStorage storage $ = _getFineTuningServingStorage();\n        $.accountMap.acknowledgeProviderSigner(msg.sender, provider, providerSigner);\n    }\n\n    function acknowledgeDeliverable(address provider, string calldata id) external {\n        FineTuningServingStorage storage $ = _getFineTuningServingStorage();\n        $.accountMap.acknowledgeDeliverable(msg.sender, provider, id);\n    }\n\n    // provider functions\n\n    function addOrUpdateService(\n        string calldata url,\n        Quota memory quota,\n        uint pricePerToken,\n        address providerSigner,\n        bool occupied,\n        string[] memory models\n    ) external {\n        FineTuningServingStorage storage $ = _getFineTuningServingStorage();\n        $.serviceMap.addOrUpdateService(msg.sender, url, quota, pricePerToken, providerSigner, occupied, models);\n        emit ServiceUpdated(msg.sender, url, quota, pricePerToken, providerSigner, occupied);\n    }\n\n    function removeService() external {\n        FineTuningServingStorage storage $ = _getFineTuningServingStorage();\n        $.serviceMap.removeService(msg.sender);\n        emit ServiceRemoved(msg.sender);\n    }\n\n    function addDeliverable(address user, string calldata id, bytes memory modelRootHash) external {\n        FineTuningServingStorage storage $ = _getFineTuningServingStorage();\n        $.accountMap.addDeliverable(user, msg.sender, id, modelRootHash);\n    }\n\n    function getDeliverable(\n        address user,\n        address provider,\n        string calldata id\n    ) public view returns (Deliverable memory) {\n        FineTuningServingStorage storage $ = _getFineTuningServingStorage();\n        return $.accountMap.getDeliverable(user, provider, id);\n    }\n\n    function getDeliverables(address user, address provider) public view returns (Deliverable[] memory) {\n        FineTuningServingStorage storage $ = _getFineTuningServingStorage();\n        return $.accountMap.getDeliverables(user, provider);\n    }\n\n    function settleFees(VerifierInput calldata verifierInput) external {\n        FineTuningServingStorage storage $ = _getFineTuningServingStorage();\n        Account storage account = $.accountMap.getAccount(verifierInput.user, msg.sender);\n\n        // Group all validation checks together for gas efficiency\n        if (account.providerSigner != verifierInput.providerSigner) {\n            revert InvalidVerifierInput(\"provider signing address is not acknowledged\");\n        }\n        if (account.nonce >= verifierInput.nonce) {\n            revert InvalidVerifierInput(\"nonce should larger than the current nonce\");\n        }\n        if (account.balance < verifierInput.taskFee) {\n            revert InvalidVerifierInput(\"insufficient balance\");\n        }\n\n        // Validate deliverable exists\n        if (bytes(account.deliverables[verifierInput.id].id).length == 0) {\n            revert(\"Deliverable does not exist\");\n        }\n        Deliverable storage deliverable = account.deliverables[verifierInput.id];\n        if (keccak256(deliverable.modelRootHash) != keccak256(verifierInput.modelRootHash)) {\n            revert InvalidVerifierInput(\"model root hash mismatch\");\n        }\n\n        // Verify TEE signature\n        bool teePassed = verifierInput.verifySignature(account.providerSigner);\n        if (!teePassed) {\n            revert InvalidVerifierInput(\"TEE settlement validation failed\");\n        }\n\n        uint fee = verifierInput.taskFee;\n        if (deliverable.acknowledged) {\n            require(verifierInput.encryptedSecret.length != 0, \"secret should not be empty\");\n            deliverable.encryptedSecret = verifierInput.encryptedSecret;\n        } else {\n            require(verifierInput.encryptedSecret.length == 0, \"secret should be empty\");\n            fee = (fee * $.penaltyPercentage) / 100;\n        }\n\n        account.nonce = verifierInput.nonce;\n        _settleFees(account, fee);\n    }\n\n    function _settleFees(Account storage account, uint amount) private {\n        FineTuningServingStorage storage $ = _getFineTuningServingStorage();\n        uint availableBalance = account.balance - account.pendingRefund;\n\n        if (amount > availableBalance) {\n            uint remainingFee = amount - availableBalance;\n            if (account.pendingRefund < remainingFee) {\n                revert InvalidVerifierInput(\"insufficient balance in pendingRefund\");\n            }\n\n            account.pendingRefund -= remainingFee;\n\n            // Optimized: Process from the end with early exit\n            uint refundsLength = account.refunds.length;\n            for (uint i = refundsLength; i > 0 && remainingFee > 0; i--) {\n                Refund storage refund = account.refunds[i - 1];\n                if (refund.processed) {\n                    continue;\n                }\n\n                if (refund.amount <= remainingFee) {\n                    remainingFee -= refund.amount;\n                    refund.amount = 0;\n                    refund.processed = true;\n                } else {\n                    refund.amount -= remainingFee;\n                    remainingFee = 0;\n                    break;\n                }\n            }\n        }\n\n        account.balance -= amount;\n        $.ledger.spendFund(account.user, amount);\n        emit BalanceUpdated(account.user, msg.sender, account.balance, account.pendingRefund);\n        payable(msg.sender).transfer(amount);\n    }\n\n    // === ERC165 Support ===\n    \n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IServing).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    receive() external payable {\n        FineTuningServingStorage storage $ = _getFineTuningServingStorage();\n        // Use ILedger interface to deposit funds for the sender\n        $.ledger.depositFundFor{value: msg.value}(msg.sender);\n    }\n}\n"
    },
    "contracts/fine-tuning/FineTuningVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nstruct VerifierInput {\n    string id; // Changed from bytes32 to string\n    bytes encryptedSecret;\n    bytes modelRootHash;\n    uint nonce;\n    address providerSigner;\n    bytes signature;\n    uint taskFee;\n    address user;\n}\n\nlibrary VerifierLibrary {\n    function verifySignature(VerifierInput memory input, address expectedAddress) internal pure returns (bool) {\n        bytes32 messageHash = getMessageHash(input);\n        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);\n        return recoverSigner(ethSignedMessageHash, input.signature) == expectedAddress;\n    }\n\n    function getMessageHash(VerifierInput memory input) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    input.encryptedSecret,\n                    input.modelRootHash,\n                    input.nonce,\n                    input.providerSigner,\n                    input.taskFee,\n                    input.user\n                )\n            );\n    }\n\n    function splitSignature(bytes memory sig) internal pure returns (uint8 v, bytes32 r, bytes32 s) {\n        require(sig.length == 65);\n\n        assembly {\n            // first 32 bytes, after the length prefix.\n            r := mload(add(sig, 32))\n            // second 32 bytes.\n            s := mload(add(sig, 64))\n            // final byte (first byte of the next 32 bytes).\n            v := byte(0, mload(add(sig, 96)))\n        }\n\n        return (v, r, s);\n    }\n\n    function recoverSigner(bytes32 message, bytes memory sig) internal pure returns (address) {\n        (uint8 v, bytes32 r, bytes32 s) = splitSignature(sig);\n        return ecrecover(message, v, r, s);\n    }\n\n    function getEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n"
    },
    "contracts/inference/InferenceAccount.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nstruct Account {\n    address user;\n    address provider;\n    uint nonce;\n    uint balance;\n    uint pendingRefund;\n    Refund[] refunds;\n    string additionalInfo;\n    bool acknowledged; // Whether user has acknowledged this provider\n    uint validRefundsLength; // Track the number of valid (non-dirty) refunds\n}\n\nstruct Refund {\n    uint index;\n    uint amount;\n    uint createdAt;\n    bool processed;\n}\n\nlibrary AccountLibrary {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // Constants for optimization\n    uint constant MAX_REFUNDS_PER_ACCOUNT = 30;\n    uint constant REFUND_CLEANUP_THRESHOLD = 15;\n\n    error AccountNotExists(address user, address provider);\n    error AccountExists(address user, address provider);\n    error InsufficientBalance(address user, address provider);\n    error RefundInvalid(address user, address provider, uint index);\n    error RefundProcessed(address user, address provider, uint index);\n    error RefundLocked(address user, address provider, uint index);\n    error TooManyRefunds(address user, address provider);\n\n    struct AccountMap {\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 => Account) _values;\n        mapping(address => EnumerableSet.Bytes32Set) _providerIndex;\n        mapping(address => EnumerableSet.Bytes32Set) _userIndex;\n    }\n\n    function getAccount(\n        AccountMap storage map,\n        address user,\n        address provider\n    ) internal view returns (Account storage) {\n        return _get(map, user, provider);\n    }\n\n    function getAllAccounts(\n        AccountMap storage map,\n        uint offset,\n        uint limit\n    ) internal view returns (Account[] memory accounts, uint total) {\n        total = _length(map);\n\n        if (offset >= total) {\n            return (new Account[](0), total);\n        }\n\n        uint end = offset + limit;\n        if (limit == 0 || end > total) {\n            end = total;\n        }\n\n        uint resultLength = end - offset;\n        accounts = new Account[](resultLength);\n\n        for (uint i = 0; i < resultLength; i++) {\n            accounts[i] = _at(map, offset + i);\n        }\n    }\n\n    function getAccountsByProvider(\n        AccountMap storage map,\n        address provider,\n        uint offset,\n        uint limit\n    ) internal view returns (Account[] memory accounts, uint total) {\n        EnumerableSet.Bytes32Set storage providerKeys = map._providerIndex[provider];\n        total = providerKeys.length();\n\n        if (offset >= total) {\n            return (new Account[](0), total);\n        }\n\n        uint end = limit == 0 ? total : offset + limit;\n        if (end > total) {\n            end = total;\n        }\n\n        uint resultLen = end - offset;\n        accounts = new Account[](resultLen);\n\n        for (uint i = 0; i < resultLen; i++) {\n            bytes32 key = providerKeys.at(offset + i);\n            accounts[i] = map._values[key];\n        }\n\n        return (accounts, total);\n    }\n\n    function getAccountsByUser(\n        AccountMap storage map,\n        address user,\n        uint offset,\n        uint limit\n    ) internal view returns (Account[] memory accounts, uint total) {\n        EnumerableSet.Bytes32Set storage userKeys = map._userIndex[user];\n        total = userKeys.length();\n\n        if (offset >= total) {\n            return (new Account[](0), total);\n        }\n\n        uint end = limit == 0 ? total : offset + limit;\n        if (end > total) {\n            end = total;\n        }\n\n        uint resultLen = end - offset;\n        accounts = new Account[](resultLen);\n\n        for (uint i = 0; i < resultLen; i++) {\n            bytes32 key = userKeys.at(offset + i);\n            accounts[i] = map._values[key];\n        }\n\n        return (accounts, total);\n    }\n\n    function getAccountCountByProvider(AccountMap storage map, address provider) internal view returns (uint) {\n        return map._providerIndex[provider].length();\n    }\n\n    function getAccountCountByUser(AccountMap storage map, address user) internal view returns (uint) {\n        return map._userIndex[user].length();\n    }\n\n    function getBatchAccountsByUsers(\n        AccountMap storage map,\n        address[] calldata users,\n        address provider\n    ) internal view returns (Account[] memory accounts) {\n        require(users.length <= 500, \"Batch size too large (max 500)\");\n        accounts = new Account[](users.length);\n\n        for (uint i = 0; i < users.length; i++) {\n            bytes32 key = _key(users[i], provider);\n            if (_contains(map, key)) {\n                accounts[i] = map._values[key];\n            }\n        }\n    }\n\n    function accountExists(AccountMap storage map, address user, address provider) internal view returns (bool) {\n        return _contains(map, _key(user, provider));\n    }\n\n    function getPendingRefund(AccountMap storage map, address user, address provider) internal view returns (uint) {\n        Account storage account = _get(map, user, provider);\n        return account.pendingRefund;\n    }\n\n    function addAccount(\n        AccountMap storage map,\n        address user,\n        address provider,\n        uint amount,\n        string memory additionalInfo\n    ) internal returns (uint, uint) {\n        bytes32 key = _key(user, provider);\n        if (_contains(map, key)) {\n            revert AccountExists(user, provider);\n        }\n\n        _set(map, key, user, provider, amount, additionalInfo);\n\n        map._providerIndex[provider].add(key);\n        map._userIndex[user].add(key);\n\n        return (amount, 0);\n    }\n\n    function deleteAccount(AccountMap storage map, address user, address provider) internal {\n        bytes32 key = _key(user, provider);\n        if (!_contains(map, key)) {\n            return;\n        }\n\n        map._providerIndex[provider].remove(key);\n        map._userIndex[user].remove(key);\n        map._keys.remove(key);\n        delete map._values[key];\n    }\n\n    function acknowledgeTEESigner(\n        AccountMap storage map,\n        address user,\n        address provider,\n        bool acknowledged\n    ) internal {\n        Account storage account = _get(map, user, provider);\n        \n        // Once acknowledged as true, can only be set back to false if balance is zero\n        if (account.acknowledged && !acknowledged) {\n            require(account.balance == 0, \"Cannot revoke acknowledgement with non-zero balance\");\n        }\n        \n        account.acknowledged = acknowledged;\n    }\n\n    function depositFund(\n        AccountMap storage map,\n        address user,\n        address provider,\n        uint cancelRetrievingAmount,\n        uint amount\n    ) internal returns (uint, uint) {\n        Account storage account = _get(map, user, provider);\n\n        if (cancelRetrievingAmount > 0 && account.refunds.length > 0) {\n            uint remainingCancel = cancelRetrievingAmount;\n            uint newPendingRefund = account.pendingRefund;\n\n            // Process refunds in-place to avoid memory allocation\n            uint writeIndex = 0;\n            for (uint i = 0; i < account.refunds.length; i++) {\n                Refund storage refund = account.refunds[i];\n\n                if (refund.processed) {\n                    continue;\n                }\n\n                if (remainingCancel >= refund.amount) {\n                    remainingCancel -= refund.amount;\n                    newPendingRefund -= refund.amount;\n                    refund.processed = true; // Mark as processed instead of removing\n                } else if (remainingCancel > 0) {\n                    refund.amount -= remainingCancel;\n                    newPendingRefund -= remainingCancel;\n                    remainingCancel = 0;\n                }\n\n                // Keep unprocessed refunds\n                if (!refund.processed && i != writeIndex) {\n                    account.refunds[writeIndex] = refund;\n                    account.refunds[writeIndex].index = writeIndex;\n                    writeIndex++;\n                } else if (!refund.processed) {\n                    writeIndex++;\n                }\n            }\n\n            // Update validRefundsLength after cancelling refunds\n            account.validRefundsLength = writeIndex;\n\n            // Cleanup if needed\n            if (writeIndex < account.refunds.length) {\n                _cleanupRefunds(account, writeIndex);\n                account.validRefundsLength = account.refunds.length; // Update after cleanup\n            }\n\n            account.pendingRefund = newPendingRefund;\n        }\n\n        account.balance += amount;\n        return (account.balance, account.pendingRefund);\n    }\n\n    function requestRefund(\n        AccountMap storage map,\n        address user,\n        address provider,\n        uint amount\n    ) internal returns (uint) {\n        Account storage account = _get(map, user, provider);\n        if ((account.balance - account.pendingRefund) < amount) {\n            revert InsufficientBalance(user, provider);\n        }\n\n        // Check refund limit using validRefundsLength\n        if (account.validRefundsLength >= MAX_REFUNDS_PER_ACCOUNT) {\n            revert TooManyRefunds(user, provider);\n        }\n\n        uint newIndex;\n        if (account.validRefundsLength < account.refunds.length) {\n            // Reuse dirty position (saves ~15,000 gas)\n            newIndex = account.validRefundsLength;\n            account.refunds[newIndex] = Refund(newIndex, amount, block.timestamp, false);\n        } else {\n            // Need to push new position\n            newIndex = account.refunds.length;\n            account.refunds.push(Refund(newIndex, amount, block.timestamp, false));\n        }\n\n        account.validRefundsLength++;\n        account.pendingRefund += amount;\n        return newIndex;\n    }\n\n    function requestRefundAll(AccountMap storage map, address user, address provider) internal {\n        Account storage account = _get(map, user, provider);\n        uint amount = account.balance - account.pendingRefund;\n        if (amount == 0) {\n            return;\n        }\n\n        // Check refund limit using validRefundsLength\n        if (account.validRefundsLength >= MAX_REFUNDS_PER_ACCOUNT) {\n            revert TooManyRefunds(user, provider);\n        }\n\n        uint newIndex;\n        if (account.validRefundsLength < account.refunds.length) {\n            // Reuse dirty position (saves ~15,000 gas)\n            newIndex = account.validRefundsLength;\n            account.refunds[newIndex] = Refund(newIndex, amount, block.timestamp, false);\n        } else {\n            // Need to push new position\n            newIndex = account.refunds.length;\n            account.refunds.push(Refund(newIndex, amount, block.timestamp, false));\n        }\n\n        account.validRefundsLength++;\n        account.pendingRefund += amount;\n    }\n\n    function processRefund(\n        AccountMap storage map,\n        address user,\n        address provider,\n        uint lockTime\n    ) internal returns (uint totalAmount, uint balance, uint pendingRefund) {\n        Account storage account = _get(map, user, provider);\n\n        if (account.refunds.length == 0) {\n            return (0, account.balance, account.pendingRefund);\n        }\n\n        totalAmount = 0;\n        pendingRefund = 0;\n        uint writeIndex = 0;\n        uint currentTime = block.timestamp;\n\n        // Process refunds in-place\n        for (uint i = 0; i < account.refunds.length; i++) {\n            Refund storage refund = account.refunds[i];\n\n            if (refund.processed) {\n                continue;\n            }\n\n            if (currentTime >= refund.createdAt + lockTime) {\n                totalAmount += refund.amount;\n                refund.processed = true; // Mark as processed\n            } else {\n                pendingRefund += refund.amount;\n                // Keep unprocessed refunds\n                if (i != writeIndex) {\n                    account.refunds[writeIndex] = refund;\n                    account.refunds[writeIndex].index = writeIndex;\n                }\n                writeIndex++;\n            }\n        }\n\n        // Update valid refunds length\n        account.validRefundsLength = writeIndex;\n\n        // Clean up or mark dirty data\n        if (writeIndex < account.refunds.length) {\n            uint dirtyCount = account.refunds.length - writeIndex;\n\n            if (dirtyCount >= REFUND_CLEANUP_THRESHOLD) {\n                // Many dirty entries: physical cleanup is more efficient\n                _cleanupRefunds(account, writeIndex);\n                account.validRefundsLength = account.refunds.length; // Update after cleanup\n            } else {\n                // Few dirty entries: mark as processed to prevent duplicate processing\n                for (uint i = writeIndex; i < account.refunds.length; i++) {\n                    account.refunds[i].processed = true;\n                }\n            }\n        }\n\n        account.balance -= totalAmount;\n        account.pendingRefund = pendingRefund;\n        balance = account.balance;\n    }\n\n    function _cleanupRefunds(Account storage account, uint keepCount) private {\n        // Resize array to remove processed refunds\n        uint currentLength = account.refunds.length;\n        for (uint i = currentLength; i > keepCount; i--) {\n            account.refunds.pop();\n        }\n    }\n\n    function _at(AccountMap storage map, uint index) internal view returns (Account storage) {\n        bytes32 key = map._keys.at(index);\n        return map._values[key];\n    }\n\n    function _contains(AccountMap storage map, bytes32 key) internal view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    function _length(AccountMap storage map) internal view returns (uint) {\n        return map._keys.length();\n    }\n\n    function _get(AccountMap storage map, address user, address provider) internal view returns (Account storage) {\n        bytes32 key = _key(user, provider);\n        if (!_contains(map, key)) {\n            revert AccountNotExists(user, provider);\n        }\n        return map._values[key];\n    }\n\n    function _set(\n        AccountMap storage map,\n        bytes32 key,\n        address user,\n        address provider,\n        uint balance,\n        string memory additionalInfo\n    ) internal {\n        Account storage account = map._values[key];\n        account.balance = balance;\n        account.user = user;\n        account.provider = provider;\n        account.additionalInfo = additionalInfo;\n        account.validRefundsLength = 0; // Initialize validRefundsLength\n        map._keys.add(key);\n    }\n\n    function _key(address user, address provider) internal pure returns (bytes32) {\n        return keccak256(abi.encode(user, provider));\n    }\n}\n"
    },
    "contracts/inference/InferenceService.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nstruct ServiceParams {\n    string serviceType;\n    string url;\n    string model;\n    string verifiability;\n    uint inputPrice;\n    uint outputPrice;\n    string additionalInfo;\n    address teeSignerAddress;\n}\n\nstruct Service {\n    address provider;\n    string serviceType;\n    string url;\n    uint inputPrice;\n    uint outputPrice;\n    uint updatedAt;\n    string model;\n    string verifiability;\n    string additionalInfo;\n    address teeSignerAddress;\n    bool teeSignerAcknowledged;\n}\n\nlibrary ServiceLibrary {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    error ServiceNotExist(address provider);\n\n    struct ServiceMap {\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 => Service) _values;\n    }\n\n    function getService(ServiceMap storage map, address provider) internal view returns (Service storage) {\n        return _get(map, provider);\n    }\n\n    function getAllServices(ServiceMap storage map) internal view returns (Service[] memory services) {\n        uint len = _length(map);\n        services = new Service[](len);\n        for (uint i = 0; i < len; ++i) {\n            services[i] = _at(map, i);\n        }\n    }\n\n    function addOrUpdateService(ServiceMap storage map, address provider, ServiceParams calldata params) internal {\n        bytes32 key = _key(provider);\n        if (!_contains(map, key)) {\n            _set(\n                map,\n                key,\n                Service(\n                    provider,\n                    params.serviceType,\n                    params.url,\n                    params.inputPrice,\n                    params.outputPrice,\n                    block.timestamp,\n                    params.model,\n                    params.verifiability,\n                    params.additionalInfo,\n                    params.teeSignerAddress,\n                    false  // teeSignerAcknowledged - default to false, needs owner acknowledgement\n                )\n            );\n            return;\n        }\n        Service storage value = _get(map, provider);\n        \n        // Check if critical fields are being changed (fields that require re-acknowledgement)\n        bool criticalFieldsChanged = (\n            keccak256(bytes(value.serviceType)) != keccak256(bytes(params.serviceType)) ||\n            keccak256(bytes(value.model)) != keccak256(bytes(params.model)) ||\n            keccak256(bytes(value.verifiability)) != keccak256(bytes(params.verifiability)) ||\n            value.teeSignerAddress != params.teeSignerAddress ||\n            keccak256(bytes(value.additionalInfo)) != keccak256(bytes(params.additionalInfo))\n        );\n        \n        // Update all fields\n        value.serviceType = params.serviceType;\n        value.inputPrice = params.inputPrice;\n        value.outputPrice = params.outputPrice;\n        value.url = params.url;\n        value.updatedAt = block.timestamp;\n        value.model = params.model;\n        value.verifiability = params.verifiability;\n        value.additionalInfo = params.additionalInfo;\n        value.teeSignerAddress = params.teeSignerAddress;\n        \n        // Reset acknowledgement if critical fields changed\n        // Only price and URL changes don't require re-acknowledgement\n        if (criticalFieldsChanged) {\n            value.teeSignerAcknowledged = false;\n        }\n    }\n\n    function removeService(ServiceMap storage map, address provider) internal {\n        bytes32 key = _key(provider);\n        if (!_contains(map, key)) {\n            revert ServiceNotExist(provider);\n        }\n        _remove(map, key);\n    }\n\n    function acknowledgeTEESigner(ServiceMap storage map, address provider) internal {\n        Service storage service = _get(map, provider);\n        service.teeSignerAcknowledged = true;\n    }\n\n    function revokeTEESignerAcknowledgement(ServiceMap storage map, address provider) internal {\n        Service storage service = _get(map, provider);\n        service.teeSignerAcknowledged = false;\n    }\n\n    function _at(ServiceMap storage map, uint index) internal view returns (Service storage) {\n        bytes32 key = map._keys.at(index);\n        return map._values[key];\n    }\n\n    function _set(ServiceMap storage map, bytes32 key, Service memory value) internal returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    function _get(ServiceMap storage map, address provider) internal view returns (Service storage) {\n        bytes32 key = _key(provider);\n        Service storage value = map._values[key];\n        if (!_contains(map, key)) {\n            revert ServiceNotExist(provider);\n        }\n        return value;\n    }\n\n    function _remove(ServiceMap storage map, bytes32 key) internal returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    function _contains(ServiceMap storage map, bytes32 key) internal view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    function _length(ServiceMap storage map) internal view returns (uint) {\n        return map._keys.length();\n    }\n\n    function _key(address provider) internal pure returns (bytes32) {\n        return keccak256(abi.encode(provider));\n    }\n}\n"
    },
    "contracts/inference/InferenceServing.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"../utils/Initializable.sol\";\nimport \"./InferenceAccount.sol\";\nimport \"./InferenceService.sol\";\nimport \"../ledger/LedgerManager.sol\";\n\nstruct TEESettlementData {\n    address user;\n    address provider;\n    uint totalFee;\n    bytes32 requestsHash;\n    uint nonce;\n    bytes signature;\n}\n\nenum SettlementStatus {\n    SUCCESS,              // 0: Full settlement success\n    PARTIAL,              // 1: Partial settlement (insufficient balance)\n    PROVIDER_MISMATCH,    // 2: Provider mismatch\n    NO_TEE_SIGNER,        // 3: TEE signer not acknowledged\n    INVALID_NONCE,        // 4: Invalid or duplicate nonce\n    INVALID_SIGNATURE     // 5: Signature verification failed\n}\n\ncontract InferenceServing is Ownable, Initializable, ReentrancyGuard, IServing, ERC165 {\n    using AccountLibrary for AccountLibrary.AccountMap;\n    using ServiceLibrary for ServiceLibrary.ServiceMap;\n\n    // @custom:storage-location erc7201:0g.serving.inference.v1.0\n    struct InferenceServingStorage {\n        uint lockTime;\n        address ledgerAddress;\n        ILedger ledger;\n        AccountLibrary.AccountMap accountMap;\n        ServiceLibrary.ServiceMap serviceMap;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"0g.serving.inference.v1.0\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INFERENCE_SERVING_STORAGE_LOCATION = 0xdfd123095cdedb1cecbc229b30f7cf8745fb3d3951645ac4a8fa4c0895f89500;\n\n    function _getInferenceServingStorage() private pure returns (InferenceServingStorage storage $) {\n        assembly {\n            $.slot := INFERENCE_SERVING_STORAGE_LOCATION\n        }\n    }\n\n    // Public getters for compatibility\n    function lockTime() public view returns (uint) {\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\n        return $.lockTime;\n    }\n\n    function ledgerAddress() public view returns (address) {\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\n        return $.ledgerAddress;\n    }\n\n    event BalanceUpdated(address indexed user, address indexed provider, uint amount, uint pendingRefund);\n    event RefundRequested(address indexed user, address indexed provider, uint indexed index, uint timestamp);\n    event ServiceUpdated(\n        address indexed service,\n        string serviceType,\n        string url,\n        uint inputPrice,\n        uint outputPrice,\n        uint updatedAt,\n        string model,\n        string verifiability\n    );\n    event ServiceRemoved(address indexed service);\n    event TEESettlementResult(address indexed user, SettlementStatus status, uint256 unsettledAmount);\n    event BatchBalanceUpdated(address[] users, uint256[] balances, uint256[] pendingRefunds);\n    event ProviderTEESignerAcknowledged(address indexed provider, address indexed teeSignerAddress, bool acknowledged);\n    error InvalidTEESignature(string reason);\n\n\n    function initialize(uint _locktime, address _ledgerAddress, address owner) public onlyInitializeOnce {\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\n        _transferOwnership(owner);\n        $.lockTime = _locktime;\n        $.ledgerAddress = _ledgerAddress;\n        $.ledger = ILedger(_ledgerAddress);\n    }\n\n    modifier onlyLedger() {\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\n        require(msg.sender == $.ledgerAddress, \"Caller is not the ledger contract\");\n        _;\n    }\n\n    function updateLockTime(uint _locktime) public onlyOwner {\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\n        $.lockTime = _locktime;\n    }\n\n    function getAccount(address user, address provider) public view returns (Account memory) {\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\n        return $.accountMap.getAccount(user, provider);\n    }\n\n    function getAllAccounts(uint offset, uint limit) public view returns (Account[] memory accounts, uint total) {\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\n        require(limit == 0 || limit <= 50, \"Limit too large\");\n        return $.accountMap.getAllAccounts(offset, limit);\n    }\n\n    function getAccountsByProvider(\n        address provider,\n        uint offset,\n        uint limit\n    ) public view returns (Account[] memory accounts, uint total) {\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\n        require(limit == 0 || limit <= 50, \"Limit too large\");\n        return $.accountMap.getAccountsByProvider(provider, offset, limit);\n    }\n\n    function getAccountsByUser(\n        address user,\n        uint offset,\n        uint limit\n    ) public view returns (Account[] memory accounts, uint total) {\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\n        require(limit == 0 || limit <= 50, \"Limit too large\");\n        return $.accountMap.getAccountsByUser(user, offset, limit);\n    }\n\n    function getBatchAccountsByUsers(address[] calldata users) external view returns (Account[] memory accounts) {\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\n        return $.accountMap.getBatchAccountsByUsers(users, msg.sender);\n    }\n\n    function acknowledgeTEESignerByOwner(address provider) external onlyOwner {\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\n        Service storage service = $.serviceMap.getService(provider);\n        $.serviceMap.acknowledgeTEESigner(provider);\n        emit ProviderTEESignerAcknowledged(provider, service.teeSignerAddress, true);\n    }\n\n    function acknowledgeTEESigner(address provider, bool acknowledged) external {\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\n        $.accountMap.acknowledgeTEESigner(msg.sender, provider, acknowledged);\n    }\n\n\n    function revokeTEESignerAcknowledgement(address provider) external onlyOwner {\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\n        Service storage service = $.serviceMap.getService(provider);\n        $.serviceMap.revokeTEESignerAcknowledgement(provider);\n        emit ProviderTEESignerAcknowledged(provider, service.teeSignerAddress, false);\n    }\n\n    function accountExists(address user, address provider) public view returns (bool) {\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\n        return $.accountMap.accountExists(user, provider);\n    }\n\n    function getPendingRefund(address user, address provider) public view returns (uint) {\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\n        return $.accountMap.getPendingRefund(user, provider);\n    }\n\n    function addAccount(\n        address user,\n        address provider,\n        string memory additionalInfo\n    ) external payable onlyLedger {\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\n        (uint balance, uint pendingRefund) = $.accountMap.addAccount(user, provider, msg.value, additionalInfo);\n        emit BalanceUpdated(user, provider, balance, pendingRefund);\n    }\n\n    function deleteAccount(address user, address provider) external onlyLedger {\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\n        $.accountMap.deleteAccount(user, provider);\n    }\n\n    function depositFund(address user, address provider, uint cancelRetrievingAmount) external payable onlyLedger {\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\n        (uint balance, uint pendingRefund) = $.accountMap.depositFund(user, provider, cancelRetrievingAmount, msg.value);\n        emit BalanceUpdated(user, provider, balance, pendingRefund);\n    }\n\n    function requestRefundAll(address user, address provider) external onlyLedger {\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\n        $.accountMap.requestRefundAll(user, provider);\n        Account memory account = $.accountMap.getAccount(user, provider);\n        if (account.refunds.length > 0) {\n            emit RefundRequested(user, provider, account.refunds.length - 1, block.timestamp);\n        }\n    }\n\n    function processRefund(\n        address user,\n        address provider\n    ) external onlyLedger returns (uint totalAmount, uint balance, uint pendingRefund) {\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\n        (totalAmount, balance, pendingRefund) = $.accountMap.processRefund(user, provider, $.lockTime);\n\n        if (totalAmount > 0) {\n            (bool success, ) = payable(msg.sender).call{value: totalAmount}(\"\");\n            require(success, \"transfer to ledger failed\");\n            emit BalanceUpdated(user, provider, balance, pendingRefund);\n        }\n    }\n\n    function getService(address provider) public view returns (Service memory service) {\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\n        service = $.serviceMap.getService(provider);\n    }\n\n    function getAllServices() public view returns (Service[] memory services) {\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\n        services = $.serviceMap.getAllServices();\n    }\n\n    function addOrUpdateService(ServiceParams calldata params) external {\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\n        $.serviceMap.addOrUpdateService(msg.sender, params);\n        emit ServiceUpdated(\n            msg.sender,\n            params.serviceType,\n            params.url,\n            params.inputPrice,\n            params.outputPrice,\n            block.timestamp,\n            params.model,\n            params.verifiability\n        );\n    }\n\n    function removeService() external {\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\n        $.serviceMap.removeService(msg.sender);\n        emit ServiceRemoved(msg.sender);\n    }\n\n    function _settleFees(Account storage account, uint amount) private {\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\n        if (amount > (account.balance - account.pendingRefund)) {\n            uint remainingFee = amount - (account.balance - account.pendingRefund);\n            account.pendingRefund -= remainingFee;\n            for (int i = int(account.refunds.length - 1); i >= 0; i--) {\n                Refund storage refund = account.refunds[uint(i)];\n                if (refund.processed) {\n                    continue;\n                }\n\n                if (refund.amount <= remainingFee) {\n                    remainingFee -= refund.amount;\n                } else {\n                    refund.amount -= remainingFee;\n                    remainingFee = 0;\n                }\n\n                if (remainingFee == 0) {\n                    break;\n                }\n            }\n        }\n        account.balance -= amount;\n        $.ledger.spendFund(account.user, amount);\n        emit BalanceUpdated(account.user, msg.sender, account.balance, account.pendingRefund);\n    }\n\n    // Static view function for previewing settlement results without state changes\n    function previewSettlementResults(\n        TEESettlementData[] calldata settlements\n    ) external view returns (\n        address[] memory failedUsers,\n        SettlementStatus[] memory failureReasons,\n        address[] memory partialUsers, \n        uint256[] memory partialAmounts\n    ) {\n        require(settlements.length > 0, \"No settlements provided\");\n\n        failedUsers = new address[](settlements.length);\n        failureReasons = new SettlementStatus[](settlements.length);\n        partialUsers = new address[](settlements.length);\n        partialAmounts = new uint256[](settlements.length);\n        \n        uint failedCount = 0;\n        uint partialCount = 0;\n\n        for (uint i = 0; i < settlements.length; i++) {\n            TEESettlementData calldata settlement = settlements[i];\n            \n            if (settlement.provider != msg.sender) {\n                _recordFailure(failedUsers, failureReasons, failedCount++, settlement.user, SettlementStatus.PROVIDER_MISMATCH);\n                continue;\n            }\n            \n            (SettlementStatus status, uint256 unsettledAmount) = _previewTEESettlement(settlement);\n            \n            if (status == SettlementStatus.SUCCESS) {\n                continue;\n            }\n            \n            if (status == SettlementStatus.PARTIAL) {\n                _recordPartial(partialUsers, partialAmounts, partialCount++, settlement.user, unsettledAmount);\n                continue;\n            }\n            _recordFailure(failedUsers, failureReasons, failedCount++, settlement.user, status);\n        }\n\n        assembly {\n            mstore(failedUsers, failedCount)\n            mstore(failureReasons, failedCount)\n            mstore(partialUsers, partialCount)\n            mstore(partialAmounts, partialCount)\n        }\n    }\n\n    function settleFeesWithTEE(\n        TEESettlementData[] calldata settlements\n    ) external returns (\n        address[] memory failedUsers,\n        SettlementStatus[] memory failureReasons,\n        address[] memory partialUsers, \n        uint256[] memory partialAmounts\n    ) {\n        require(settlements.length > 0, \"No settlements provided\");\n        require(settlements.length <= 50, \"Too many settlements in batch\");\n\n        failedUsers = new address[](settlements.length);\n        failureReasons = new SettlementStatus[](settlements.length);\n        partialUsers = new address[](settlements.length);\n        partialAmounts = new uint256[](settlements.length);\n        \n        uint failedCount = 0;\n        uint partialCount = 0;\n        uint256 totalTransferAmount = 0;\n\n        for (uint i = 0; i < settlements.length; i++) {\n            TEESettlementData calldata settlement = settlements[i];\n            \n            if (settlement.provider != msg.sender) {\n                _recordFailure(failedUsers, failureReasons, failedCount++, settlement.user, SettlementStatus.PROVIDER_MISMATCH);\n                emit TEESettlementResult(settlement.user, SettlementStatus.PROVIDER_MISMATCH, settlement.totalFee);\n                continue;\n            }\n            \n            (SettlementStatus status, uint256 unsettledAmount, uint256 settledAmount) = _processTEESettlement(settlement);\n            totalTransferAmount += settledAmount;\n            emit TEESettlementResult(settlement.user, status, unsettledAmount);\n            \n            if (status == SettlementStatus.SUCCESS) {\n                continue;\n            }\n            \n            if (status == SettlementStatus.PARTIAL) {\n                _recordPartial(partialUsers, partialAmounts, partialCount++, settlement.user, unsettledAmount);\n                continue;\n            }\n            _recordFailure(failedUsers, failureReasons, failedCount++, settlement.user, status);\n        }\n\n        assembly {\n            mstore(failedUsers, failedCount)\n            mstore(failureReasons, failedCount)\n            mstore(partialUsers, partialCount)\n            mstore(partialAmounts, partialCount)\n        }\n\n        // Batch transfer all settled amounts at once\n        if (totalTransferAmount > 0) {\n            payable(msg.sender).transfer(totalTransferAmount);\n        }\n    }\n\n    // View function to preview settlement without state changes\n    function _previewTEESettlement(TEESettlementData calldata settlement) private view returns (SettlementStatus status, uint256 unsettledAmount) {\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\n        Account storage account = $.accountMap.getAccount(settlement.user, msg.sender);\n\n        // Validate TEE signer acknowledgement - both user and service must be acknowledged, and service must have valid TEE signer address\n        Service storage service = $.serviceMap.getService(msg.sender);\n        if (!account.acknowledged || !service.teeSignerAcknowledged || service.teeSignerAddress == address(0)) {\n            return (SettlementStatus.NO_TEE_SIGNER, settlement.totalFee);\n        }\n\n        // Validate nonce (check if nonce would be valid)\n        if (account.nonce >= settlement.nonce) {\n            return (SettlementStatus.INVALID_NONCE, settlement.totalFee);\n        }\n\n        // Validate signature using service TEE signer address\n        if (!_verifySignature(settlement, service.teeSignerAddress)) {\n            return (SettlementStatus.INVALID_SIGNATURE, settlement.totalFee);\n        }\n\n        // Calculate settlement amounts (without modifying state)\n        uint256 balance = account.balance;\n        uint256 unsettled = settlement.totalFee > balance ? settlement.totalFee - balance : 0;\n        \n        // Return appropriate status\n        if (unsettled > 0) {\n            return (SettlementStatus.PARTIAL, unsettled);\n        } else {\n            return (SettlementStatus.SUCCESS, 0);\n        }\n    }\n\n    function _processTEESettlement(TEESettlementData calldata settlement) private returns (SettlementStatus status, uint256 unsettledAmount, uint256 settledAmount) {\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\n        Account storage account = $.accountMap.getAccount(settlement.user, msg.sender);\n\n        // Validate TEE signer acknowledgement - both user and service must be acknowledged, and service must have valid TEE signer address\n        Service storage service = $.serviceMap.getService(msg.sender);\n        if (!account.acknowledged || !service.teeSignerAcknowledged || service.teeSignerAddress == address(0)) {\n            return (SettlementStatus.NO_TEE_SIGNER, settlement.totalFee, 0);\n        }\n\n        // Validate nonce\n        if (account.nonce >= settlement.nonce) {\n            return (SettlementStatus.INVALID_NONCE, settlement.totalFee, 0);\n        }\n\n        // Validate signature using service TEE signer address\n        if (!_verifySignature(settlement, service.teeSignerAddress)) {\n            return (SettlementStatus.INVALID_SIGNATURE, settlement.totalFee, 0);\n        }\n\n        // All validations passed, update nonce\n        account.nonce = settlement.nonce;\n\n        // Calculate settlement amounts\n        uint256 balance = account.balance;\n        uint256 toSettle = settlement.totalFee > balance ? balance : settlement.totalFee;\n        uint256 unsettled = settlement.totalFee > balance ? settlement.totalFee - balance : 0;\n        \n        // Settle what we can\n        if (toSettle > 0) {\n            _settleFees(account, toSettle);\n        }\n\n        // Return appropriate status\n        if (unsettled > 0) {\n            return (SettlementStatus.PARTIAL, unsettled, toSettle);\n        } else {\n            return (SettlementStatus.SUCCESS, 0, toSettle);\n        }\n    }\n\n    function _verifySignature(TEESettlementData calldata settlement, address expectedSigner) private pure returns (bool) {\n        bytes calldata signature = settlement.signature;\n        if (signature.length != 65) return false;\n        \n        bytes32 messageHash = keccak256(abi.encodePacked(\n            settlement.requestsHash,\n            settlement.nonce,\n            settlement.provider,\n            settlement.user,\n            settlement.totalFee\n        ));\n        \n        bytes32 ethSignedHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", messageHash));\n        \n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        \n        assembly {\n            r := calldataload(add(signature.offset, 0))\n            s := calldataload(add(signature.offset, 32))\n            v := byte(0, calldataload(add(signature.offset, 64)))\n        }\n        \n        if (v < 27) v += 27;\n        \n        return ecrecover(ethSignedHash, v, r, s) == expectedSigner;\n    }\n\n    function _recordFailure(\n        address[] memory failedUsers,\n        SettlementStatus[] memory failureReasons,\n        uint index,\n        address user,\n        SettlementStatus reason\n    ) private pure {\n        failedUsers[index] = user;\n        failureReasons[index] = reason;\n    }\n\n    function _recordPartial(\n        address[] memory partialUsers,\n        uint256[] memory partialAmounts,\n        uint index,\n        address user,\n        uint256 amount\n    ) private pure {\n        partialUsers[index] = user;\n        partialAmounts[index] = amount;\n    }\n\n    // === ERC165 Support ===\n    \n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IServing).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    receive() external payable {\n        InferenceServingStorage storage $ = _getInferenceServingStorage();\n        // Use ILedger interface to deposit funds for the sender\n        $.ledger.depositFundFor{value: msg.value}(msg.sender);\n    }\n}\n"
    },
    "contracts/ledger/LedgerManager.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport \"../utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\ninterface IServing {\n    function accountExists(address user, address provider) external view returns (bool);\n    function getPendingRefund(address user, address provider) external view returns (uint);\n    function addAccount(address user, address provider, string memory additionalInfo) external payable;\n    function depositFund(address user, address provider, uint cancelRetrievingAmount) external payable;\n    function requestRefundAll(address user, address provider) external;\n    function processRefund(address user, address provider) external returns (uint totalAmount, uint balance, uint pendingRefund);\n    function deleteAccount(address user, address provider) external;\n}\n\n// Simplified ledger structure\nstruct Ledger {\n    address user;\n    uint availableBalance;\n    uint totalBalance;\n    string additionalInfo;\n}\n\n// Service information structure\nstruct ServiceInfo {\n    address serviceAddress;\n    IServing serviceContract;\n    string serviceType; // \"inference\" or \"fine-tuning\"\n    string version;     // \"v1.0\", \"v2.0\" etc.\n    string fullName;    // \"inference-v2.0\"\n    string description;\n    bool isRecommended; // Whether this is the recommended version for this service type\n    uint256 registeredAt;\n}\n\ninterface ILedger {\n    function spendFund(address user, uint amount) external;\n    function depositFundFor(address recipient) external payable;\n}\n\n\ncontract LedgerManager is Ownable, Initializable, ReentrancyGuard {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using ERC165Checker for address;\n\n    // @custom:storage-location erc7201:0g.serving.ledger\n    struct LedgerManagerStorage {\n        // Service registry (using address as key)\n        mapping(address => ServiceInfo) registeredServices;\n        mapping(string => address) serviceNameToAddress; // \"inference-v2.0\" => address\n        EnumerableSet.AddressSet serviceAddresses;\n        \n        LedgerMap ledgerMap;\n        mapping(address => mapping(string => EnumerableSet.AddressSet)) userServiceProviders; // user => serviceType => providers\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"0g.serving.ledger\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant LEDGER_MANAGER_STORAGE_LOCATION = 0x0bb5d42557ea6926c17416c5b1c1c29c28d9006d6f713295a2d385f07156ed00;\n\n    function _getLedgerManagerStorage() private pure returns (LedgerManagerStorage storage $) {\n        assembly {\n            $.slot := LEDGER_MANAGER_STORAGE_LOCATION\n        }\n    }\n\n    // Constants\n    uint public constant MAX_PROVIDERS_PER_BATCH = 20;\n    bytes4 private constant SERVING_INTERFACE_ID = type(IServing).interfaceId;\n\n    // Events\n    event ServiceRegistered(address indexed serviceAddress, string serviceName);\n    event RecommendedServiceUpdated(string indexed serviceType, string version, address serviceAddress);\n\n    // Errors\n    error LedgerNotExists(address user);\n    error LedgerExists(address user);\n    error InsufficientBalance(address user);\n    error TooManyProviders(uint requested, uint maximum);\n    error InvalidServiceType(string serviceType);\n    error ServiceNotRegistered(address serviceAddress);\n    error ServiceNameExists(string serviceName);\n    error InvalidServiceAddress(address serviceAddress);\n\n    struct LedgerMap {\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 => Ledger) _values;\n        // Operation locks to prevent reentrancy\n        mapping(bytes32 => bool) _operationLocks;\n    }\n\n    // Prevent reentrancy on ledger operations\n    modifier withLedgerLock(address user) {\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\n        bytes32 key = _key(user);\n        require(!$.ledgerMap._operationLocks[key], \"Ledger locked for operation\");\n        $.ledgerMap._operationLocks[key] = true;\n        _;\n        $.ledgerMap._operationLocks[key] = false;\n    }\n\n    function initialize(\n        address owner\n    ) public onlyInitializeOnce {\n        _transferOwnership(owner);\n    }\n\n    modifier onlyServing() {\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\n        require(\n            $.registeredServices[msg.sender].serviceAddress != address(0),\n            \"Caller is not a registered service\"\n        );\n        _;\n    }\n\n    function getLedger(address user) public view returns (Ledger memory) {\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\n        return _get($, user);\n    }\n\n    function getAllLedgers(uint offset, uint limit) public view returns (Ledger[] memory ledgers, uint total) {\n        total = _length();\n\n        if (offset >= total) {\n            return (new Ledger[](0), total);\n        }\n\n        uint end = limit == 0 ? total : Math.min(offset + limit, total);\n        uint resultLen = end - offset;\n        ledgers = new Ledger[](resultLen);\n\n        for (uint i = 0; i < resultLen; i++) {\n            ledgers[i] = _at(offset + i);\n        }\n\n        return (ledgers, total);\n    }\n\n    // Get providers for a specific user and service\n    function getLedgerProviders(address user, string memory serviceName) public view returns (address[] memory) {\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\n        address serviceAddress = $.serviceNameToAddress[serviceName];\n        require(serviceAddress != address(0), \"Service not found\");\n        \n        string memory serviceType = $.registeredServices[serviceAddress].serviceType;\n        EnumerableSet.AddressSet storage providers = $.userServiceProviders[user][serviceType];\n        address[] memory providerList = new address[](providers.length());\n        \n        for (uint256 i = 0; i < providers.length(); i++) {\n            providerList[i] = providers.at(i);\n        }\n        \n        return providerList;\n    }\n\n    function addLedger(\n        string memory additionalInfo\n    ) external payable withLedgerLock(msg.sender) returns (uint, uint) {\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\n        bytes32 key = _key(msg.sender);\n        if (_contains($, key)) {\n            revert LedgerExists(msg.sender);\n        }\n        _set($, key, msg.sender, msg.value, additionalInfo);\n        return (msg.value, 0);\n    }\n\n    function depositFund() external payable withLedgerLock(msg.sender) {\n        _depositFundInternal(msg.sender, msg.value);\n    }\n    \n    // Internal function for deposit logic without modifier\n    function _depositFundInternal(address user, uint256 amount) internal {\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\n        bytes32 key = _key(user);\n        \n        // Create account if it doesn't exist\n        if (!_contains($, key)) {\n            _set($, key, user, amount, \"\");\n        } else {\n            Ledger storage ledger = $.ledgerMap._values[key];\n            ledger.availableBalance += amount;\n            ledger.totalBalance += amount;\n        }\n    }\n\n    function depositFundFor(address recipient) external payable withLedgerLock(recipient) {\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\n        bytes32 key = _key(recipient);\n        \n        // Create account if it doesn't exist\n        if (!_contains($, key)) {\n            _set($, key, recipient, msg.value, \"\");\n        } else {\n            Ledger storage ledger = $.ledgerMap._values[key];\n            ledger.availableBalance += msg.value;\n            ledger.totalBalance += msg.value;\n        }\n    }\n\n    function refund(uint amount) external withLedgerLock(msg.sender) {\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\n        Ledger storage ledger = _get($, msg.sender);\n        if (ledger.availableBalance < amount) {\n            revert InsufficientBalance(msg.sender);\n        }\n\n        ledger.availableBalance -= amount;\n        ledger.totalBalance -= amount;\n        payable(msg.sender).transfer(amount);\n    }\n\n    // Enhanced transferFund with dynamic service support\n    function transferFund(\n        address provider,\n        string memory serviceName,\n        uint amount\n    ) external withLedgerLock(msg.sender) {\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\n        Ledger storage ledger = _get($, msg.sender);\n        \n        // Dynamic service lookup\n        address serviceAddress = $.serviceNameToAddress[serviceName];\n        require(serviceAddress != address(0), \"Service not found\");\n        \n        ServiceInfo storage service = $.registeredServices[serviceAddress];\n        \n        address servingAddress = service.serviceAddress;\n        IServing serving = service.serviceContract;\n\n        uint transferAmount = amount;\n        bytes memory payload;\n\n        if (serving.accountExists(msg.sender, provider)) {\n            // Account exists - handle pending refunds\n            uint retrievingAmount = serving.getPendingRefund(msg.sender, provider);\n            uint cancelRetrievingAmount = Math.min(amount, retrievingAmount);\n            transferAmount -= cancelRetrievingAmount;\n\n            payload = abi.encodeWithSignature(\n                \"depositFund(address,address,uint256)\",\n                msg.sender,\n                provider,\n                cancelRetrievingAmount\n            );\n        } else {\n            // New account - use unified addAccount interface\n            payload = abi.encodeWithSignature(\n                \"addAccount(address,address,string)\",\n                msg.sender,\n                provider,\n                ledger.additionalInfo\n            );\n            \n            // Add provider to service storage\n            _addProviderToService($, msg.sender, service.serviceType, provider);\n        }\n\n        require(ledger.availableBalance >= transferAmount, \"Insufficient balance\");\n        ledger.availableBalance -= transferAmount;\n\n        (bool success, ) = servingAddress.call{value: transferAmount}(payload);\n        require(success, \"Call to child contract failed\");\n    }\n\n    function retrieveFund(\n        address[] memory providers,\n        string memory serviceType\n    ) external withLedgerLock(msg.sender) {\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\n        if (providers.length > MAX_PROVIDERS_PER_BATCH) {\n            revert TooManyProviders(providers.length, MAX_PROVIDERS_PER_BATCH);\n        }\n\n        // Dynamic service lookup\n        address serviceAddress = $.serviceNameToAddress[serviceType];\n        require(serviceAddress != address(0), \"Service not found\");\n        \n        ServiceInfo storage service = $.registeredServices[serviceAddress];\n        \n        IServing serving = service.serviceContract;\n        \n        Ledger storage ledger = _get($, msg.sender);\n        uint totalAmount = 0;\n\n        for (uint i = 0; i < providers.length; i++) {\n            (uint amount, , ) = serving.processRefund(msg.sender, providers[i]);\n            totalAmount += amount;\n            serving.requestRefundAll(msg.sender, providers[i]);\n        }\n        ledger.availableBalance += totalAmount;\n    }\n\n    function deleteLedger() external nonReentrant withLedgerLock(msg.sender) {\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\n        Ledger storage ledger = _get($, msg.sender);\n        \n        // Safety check: ensure all funds have been withdrawn\n        require(ledger.totalBalance == 0, \"Must withdraw all funds first\");\n        \n        bytes32 key = _key(msg.sender);\n\n        // Delete all service accounts dynamically\n        uint256 serviceCount = $.serviceAddresses.length();\n        for (uint256 i = 0; i < serviceCount; i++) {\n            address serviceAddress = $.serviceAddresses.at(i);\n            ServiceInfo storage service = $.registeredServices[serviceAddress];\n            \n            EnumerableSet.AddressSet storage providers = $.userServiceProviders[msg.sender][service.serviceType];\n            address[] memory providerList = new address[](providers.length());\n            for (uint j = 0; j < providers.length(); j++) {\n                providerList[j] = providers.at(j);\n            }\n            \n            for (uint j = 0; j < providerList.length; j++) {\n                try service.serviceContract.deleteAccount(msg.sender, providerList[j]) {\n                    providers.remove(providerList[j]);\n                } catch {\n                    providers.remove(providerList[j]); // Remove even on failure\n                }\n            }\n        }\n\n        // Delete main ledger\n        $.ledgerMap._keys.remove(key);\n        delete $.ledgerMap._values[key];\n    }\n\n    // === Service Registration Management ===\n\n    function registerService(\n        string memory serviceType,\n        string memory version,\n        address serviceAddress,\n        string memory description\n    ) external onlyOwner {\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\n        require(serviceAddress != address(0), \"Invalid service address\");\n        require(bytes(serviceType).length > 0, \"Service type required\");\n        require(bytes(version).length > 0, \"Version required\");\n        require($.registeredServices[serviceAddress].serviceAddress == address(0), \"Service already registered\");\n        \n        string memory fullName = string(abi.encodePacked(serviceType, \"-\", version));\n        require($.serviceNameToAddress[fullName] == address(0), \"Service name already exists\");\n        \n        // Check interface support\n        require(\n            serviceAddress.supportsInterface(type(IERC165).interfaceId),\n            \"Service must support ERC165 interface detection\"\n        );\n        require(\n            serviceAddress.supportsInterface(SERVING_INTERFACE_ID),\n            \"Service must implement IServing interface\"\n        );\n        \n        // Register service (default not recommended)\n        $.registeredServices[serviceAddress] = ServiceInfo({\n            serviceAddress: serviceAddress,\n            serviceContract: IServing(serviceAddress),\n            serviceType: serviceType,\n            version: version,\n            fullName: fullName,\n            description: description,\n            isRecommended: false, // Default not recommended\n            registeredAt: block.timestamp\n        });\n        \n        $.serviceNameToAddress[fullName] = serviceAddress;\n        $.serviceAddresses.add(serviceAddress);\n        \n        emit ServiceRegistered(serviceAddress, fullName);\n    }\n\n    function setRecommendedService(\n        string memory serviceType,\n        string memory version\n    ) external onlyOwner {\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\n        string memory fullName = string(abi.encodePacked(serviceType, \"-\", version));\n        address serviceAddress = $.serviceNameToAddress[fullName];\n        require(serviceAddress != address(0), \"Service not found\");\n        \n        // Clear all recommended flags for this service type\n        _clearRecommendedServices($, serviceType);\n        \n        // Set new recommended service\n        $.registeredServices[serviceAddress].isRecommended = true;\n        \n        emit RecommendedServiceUpdated(serviceType, version, serviceAddress);\n    }\n    \n    function _clearRecommendedServices(LedgerManagerStorage storage $, string memory serviceType) internal {\n        uint256 count = $.serviceAddresses.length();\n        for (uint256 i = 0; i < count; i++) {\n            address serviceAddr = $.serviceAddresses.at(i);\n            ServiceInfo storage service = $.registeredServices[serviceAddr];\n            \n            if (keccak256(abi.encodePacked(service.serviceType)) == keccak256(abi.encodePacked(serviceType))) {\n                service.isRecommended = false;\n            }\n        }\n    }\n\n    function getServiceInfo(address serviceAddress) external view returns (ServiceInfo memory) {\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\n        return $.registeredServices[serviceAddress];\n    }\n\n    function getServiceAddressByName(string memory serviceName) external view returns (address) {\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\n        return $.serviceNameToAddress[serviceName];\n    }\n\n    function getAllActiveServices() external view returns (ServiceInfo[] memory) {\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\n        uint256 count = $.serviceAddresses.length();\n        ServiceInfo[] memory services = new ServiceInfo[](count);\n        \n        for (uint256 i = 0; i < count; i++) {\n            address serviceAddress = $.serviceAddresses.at(i);\n            services[i] = $.registeredServices[serviceAddress];\n        }\n        \n        return services;\n    }\n    \n    function getRecommendedService(string memory serviceType) \n        external view returns (string memory version, address serviceAddress) {\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\n        uint256 count = $.serviceAddresses.length();\n        for (uint256 i = 0; i < count; i++) {\n            address addr = $.serviceAddresses.at(i);\n            ServiceInfo storage service = $.registeredServices[addr];\n            \n            if (keccak256(abi.encodePacked(service.serviceType)) == keccak256(abi.encodePacked(serviceType)) \n                && service.isRecommended) {\n                return (service.version, addr);\n            }\n        }\n        revert(\"No recommended service found for this type\");\n    }\n    \n    function getAllVersions(string memory serviceType) \n        external view returns (\n            string[] memory versions,\n            address[] memory addresses,\n            bool[] memory isRecommendedFlags\n        ) {\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\n        // First count matching services\n        uint256 count = $.serviceAddresses.length();\n        uint256 matchCount = 0;\n        for (uint256 i = 0; i < count; i++) {\n            address addr = $.serviceAddresses.at(i);\n            ServiceInfo storage service = $.registeredServices[addr];\n            if (keccak256(abi.encodePacked(service.serviceType)) == keccak256(abi.encodePacked(serviceType))) {\n                matchCount++;\n            }\n        }\n        \n        // Allocate arrays\n        versions = new string[](matchCount);\n        addresses = new address[](matchCount);\n        isRecommendedFlags = new bool[](matchCount);\n        \n        // Fill arrays\n        uint256 index = 0;\n        for (uint256 i = 0; i < count; i++) {\n            address addr = $.serviceAddresses.at(i);\n            ServiceInfo storage service = $.registeredServices[addr];\n            if (keccak256(abi.encodePacked(service.serviceType)) == keccak256(abi.encodePacked(serviceType))) {\n                versions[index] = service.version;\n                addresses[index] = addr;\n                isRecommendedFlags[index] = service.isRecommended;\n                index++;\n            }\n        }\n    }\n    \n    function isRecommendedVersion(string memory serviceType, string memory version)\n        external view returns (bool) {\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\n        string memory fullName = string(abi.encodePacked(serviceType, \"-\", version));\n        address serviceAddress = $.serviceNameToAddress[fullName];\n        if (serviceAddress == address(0)) {\n            return false;\n        }\n        return $.registeredServices[serviceAddress].isRecommended;\n    }\n\n    function _addProviderToService(LedgerManagerStorage storage $, address user, string memory serviceType, address provider) private {\n        EnumerableSet.AddressSet storage providers = $.userServiceProviders[user][serviceType];\n        providers.add(provider);\n    }\n\n    function spendFund(address user, uint amount) external onlyServing {\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\n        // Use withLedgerLock to ensure single-user atomicity\n        bytes32 key = _key(user);\n        require(!$.ledgerMap._operationLocks[key], \"Ledger locked for operation\");\n        $.ledgerMap._operationLocks[key] = true;\n        \n        Ledger storage ledger = _get($, user);\n        require((ledger.totalBalance - ledger.availableBalance) >= amount, \"Insufficient balance\");\n        ledger.totalBalance -= amount;\n        \n        $.ledgerMap._operationLocks[key] = false;\n    }\n\n    function _at(uint index) internal view returns (Ledger storage) {\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\n        bytes32 key = $.ledgerMap._keys.at(index);\n        return $.ledgerMap._values[key];\n    }\n\n    function _contains(LedgerManagerStorage storage $, bytes32 key) internal view returns (bool) {\n        return $.ledgerMap._keys.contains(key);\n    }\n\n    function _length() internal view returns (uint) {\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\n        return $.ledgerMap._keys.length();\n    }\n\n    function _get(LedgerManagerStorage storage $, address user) internal view returns (Ledger storage) {\n        bytes32 key = _key(user);\n        if (!_contains($, key)) {\n            revert LedgerNotExists(user);\n        }\n        return $.ledgerMap._values[key];\n    }\n\n    // Simplified _set without signer parameter\n    function _set(\n        LedgerManagerStorage storage $,\n        bytes32 key,\n        address user,\n        uint balance,\n        string memory additionalInfo\n    ) internal {\n        Ledger storage ledger = $.ledgerMap._values[key];\n        ledger.availableBalance = balance;\n        ledger.totalBalance = balance;\n        ledger.user = user;\n        ledger.additionalInfo = additionalInfo;\n        $.ledgerMap._keys.add(key);\n    }\n\n    function _key(address user) internal pure returns (bytes32) {\n        return keccak256(abi.encode(user));\n    }\n\n    receive() external payable {\n        if (_isServiceContract(msg.sender)) {\n            return;\n        }\n        \n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\n        bytes32 key = _key(tx.origin);\n        \n        // Check and set lock\n        require(!$.ledgerMap._operationLocks[key], \"Ledger locked for operation\");\n        $.ledgerMap._operationLocks[key] = true;\n        \n        // Deposit funds using internal function  \n        _depositFundInternal(tx.origin, msg.value);\n        \n        // Release lock\n        $.ledgerMap._operationLocks[key] = false;\n    }\n\n    function _isServiceContract(address sender) internal view returns (bool) {\n        LedgerManagerStorage storage $ = _getLedgerManagerStorage();\n        return $.registeredServices[sender].serviceAddress != address(0);\n    }\n}\n"
    },
    "contracts/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\ncontract Initializable {\n    bool public initialized;\n\n    modifier onlyInitializeOnce() {\n        require(!initialized, \"Initializable: already initialized\");\n        initialized = true;\n        _;\n    }\n}\n"
    }
  },
  "settings": {
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode.object",
          "evm.deployedBytecode.object",
          "abi",
          "evm.bytecode.sourceMap",
          "evm.deployedBytecode.sourceMap",
          "metadata",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "evmVersion": "istanbul",
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}